<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PBP Matchup Analysis ‚Äî Georgia vs Arizona State</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: { extend: { fontFamily: { sans: ['Inter', 'system-ui', 'sans-serif'] } } }
        }
    </script>
    <style>
        body { font-family: 'Inter', system-ui, sans-serif; background: #09090b; color: #fafafa; }
        .glass { background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06); }
        .stat-card { transition: all 0.2s ease; }
        .stat-card:hover { transform: translateY(-2px); box-shadow: 0 8px 24px -8px rgba(0,0,0,0.4); }
        .stat-card:hover .dq-info { opacity: 0.85; }
        .dq-badge { display: inline-flex; align-items: center; gap: 0.35rem; padding: 0.2rem 0.55rem; border-radius: 999px; border: 1px solid transparent; font-size: 0.68rem; letter-spacing: 0.02em; }
        .dq-green { color: #86efac; background: rgba(34,197,94,0.14); border-color: rgba(34,197,94,0.35); }
        .dq-yellow { color: #fde68a; background: rgba(234,179,8,0.14); border-color: rgba(234,179,8,0.35); }
        .dq-red { color: #fca5a5; background: rgba(239,68,68,0.16); border-color: rgba(239,68,68,0.35); }
        .dq-neutral { color: #a1a1aa; background: rgba(113,113,122,0.12); border-color: rgba(113,113,122,0.28); }
        .dq-tooltip { position: relative; display: inline-flex; align-items: center; }
        .dq-tooltip-content { position: absolute; left: 50%; bottom: calc(100% + 8px); transform: translate(-50%, -4px); min-width: 180px; max-width: 240px; background: #111114; border: 1px solid rgba(255,255,255,0.1); border-radius: 10px; padding: 0.5rem 0.6rem; font-size: 0.72rem; color: #e4e4e7; opacity: 0; pointer-events: none; transition: opacity 0.15s ease, transform 0.15s ease; z-index: 20; box-shadow: 0 10px 24px rgba(0,0,0,0.4); }
        .dq-tooltip:hover .dq-tooltip-content { opacity: 1; transform: translate(-50%, -8px); pointer-events: auto; }
        .dq-icon { width: 14px; height: 14px; border-radius: 999px; border: 1px solid currentColor; display: inline-flex; align-items: center; justify-content: center; font-size: 9px; line-height: 1; font-weight: 700; }
        .dq-info { opacity: 0.4; transition: opacity 0.2s ease; }
        .dq-warning { font-size: 0.7rem; line-height: 1; margin-left: 2px; opacity: 0.7; font-weight: 700; }
        .dq-outlier { font-size: 0.65rem; padding: 0.12rem 0.35rem; border-radius: 999px; border: 1px solid rgba(244,114,182,0.4); color: #f9a8d4; background: rgba(244,114,182,0.14); }
        .nav-pill { transition: all 0.15s ease; }
        .nav-pill:hover { background: rgba(255,255,255,0.08); }
        .nav-pill.active { background: rgba(239,68,68,0.15); color: #ef4444; border-color: rgba(239,68,68,0.3); }
        .filter-chip { transition: all 0.15s ease; cursor: pointer; }
        .filter-chip:hover { background: rgba(255,255,255,0.08); }
        .filter-chip.active { background: rgba(239,68,68,0.15); color: #ef4444; border-color: rgba(239,68,68,0.4); }
        .table-row:hover { background: rgba(255,255,255,0.03); }
        .team-a { color: #ef4444; }
        .team-b { color: #f97316; }
        .team-a-bg { background: rgba(239,68,68,0.1); border-color: rgba(239,68,68,0.2); }
        .team-b-bg { background: rgba(249,115,22,0.1); border-color: rgba(249,115,22,0.2); }
        .team-a-bar { background: #ef4444; }
        .team-b-bar { background: #f97316; }
        .context-badge { display: inline-flex; align-items: center; gap: 0.35rem; padding: 0.35rem 0.7rem; border-radius: 999px; border: 1px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.04); font-size: 0.72rem; color: #e4e4e7; }
        .context-badge.team-a-badge { border-color: rgba(239,68,68,0.35); background: rgba(239,68,68,0.08); }
        .context-badge.team-b-badge { border-color: rgba(249,115,22,0.35); background: rgba(249,115,22,0.08); }
        .rank-badge { display: inline-flex; align-items: center; padding: 0.12rem 0.45rem; border-radius: 999px; border: 1px solid transparent; font-size: 0.62rem; letter-spacing: 0.02em; text-transform: uppercase; }
        .rank-badge.good { border-color: rgba(34,197,94,0.35); background: rgba(34,197,94,0.12); color: #86efac; }
        .rank-badge.mid { border-color: rgba(148,163,184,0.35); background: rgba(148,163,184,0.12); color: #e2e8f0; }
        .rank-badge.low { border-color: rgba(249,115,22,0.35); background: rgba(249,115,22,0.12); color: #fdba74; }
        .rank-badge.bad { border-color: rgba(239,68,68,0.35); background: rgba(239,68,68,0.12); color: #fca5a5; }
        .section-enter { animation: sectionEnter 0.4s ease-out; }
        @keyframes sectionEnter { from { opacity: 0; transform: translateY(12px); } to { opacity: 1; transform: translateY(0); } }
        .schedule-row:hover { background: rgba(255,255,255,0.04); }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 3px; }
        .vs-badge { background: linear-gradient(135deg, #ef4444, #f97316); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .collapsible-body { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
        .collapsible-body.open { max-height: 320px; overflow-y: auto; }
        .chevron { transition: transform 0.3s ease; }
        .chevron.open { transform: rotate(180deg); }
        .vt-logo-icon { background: rgba(255,255,255,0.95); padding: 4px; border-radius: 8px; }
        .menu-button { display: inline-flex; align-items: center; gap: 0.4rem; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.04); color: #e4e4e7; font-size: 0.75rem; font-weight: 600; padding: 0.45rem 0.7rem; border-radius: 0.5rem; transition: all 0.15s ease; }
        .menu-button:hover { background: rgba(255,255,255,0.08); }
        .menu-panel { position: absolute; right: 0; top: calc(100% + 0.5rem); min-width: 190px; background: rgba(9,9,11,0.98); border: 1px solid rgba(255,255,255,0.12); border-radius: 0.75rem; box-shadow: 0 12px 30px rgba(0,0,0,0.45); padding: 0.35rem; z-index: 60; }
        .menu-item { width: 100%; display: flex; align-items: center; gap: 0.5rem; text-align: left; padding: 0.5rem 0.6rem; font-size: 0.75rem; color: #e4e4e7; border-radius: 0.55rem; transition: background 0.15s ease, color 0.15s ease; }
        .menu-item:hover { background: rgba(255,255,255,0.08); color: #fff; }
        .menu-divider { height: 1px; background: rgba(255,255,255,0.08); margin: 0.35rem 0.4rem; }
        .zone-section { border: 1px solid rgba(255,255,255,0.06); border-left-width: 4px; border-radius: 16px; padding: 16px; }
        .zone-green { border-left-color: #22c55e; background: linear-gradient(90deg, rgba(34,197,94,0.14), rgba(9,9,11,0) 65%); }
        .zone-red { border-left-color: #ef4444; background: linear-gradient(90deg, rgba(239,68,68,0.14), rgba(9,9,11,0) 65%); }
        .zone-tight { border-left-color: #c2410c; background: linear-gradient(90deg, rgba(194,65,12,0.16), rgba(9,9,11,0) 65%); }
        .zone-title { display: inline-flex; align-items: baseline; gap: 0.5rem; }
        .zone-title.zone-title-green { color: #86efac; }
        .zone-title.zone-title-red { color: #fca5a5; }
        .zone-title.zone-title-tight { color: #fdba74; }
        .spinner { width: 36px; height: 36px; border: 3px solid rgba(255,255,255,0.15); border-top-color: #ef4444; border-radius: 999px; animation: spin 0.8s linear infinite; }
        .state-card { border: 1px solid rgba(255,255,255,0.08); background: rgba(255,255,255,0.03); border-radius: 16px; padding: 2rem; text-align: center; }
        .chart-shell { position: relative; width: 100%; border-radius: 12px; overflow: hidden; }
        .chart-surface { position: relative; width: 100%; height: 100%; }
        .chart-skeleton { position: absolute; inset: 0; background: linear-gradient(110deg, rgba(255,255,255,0.05) 8%, rgba(255,255,255,0.12) 18%, rgba(255,255,255,0.05) 33%); background-size: 200% 100%; animation: shimmer 1.4s ease-in-out infinite; }
        .chart-shell.chart-ready .chart-skeleton { opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
        .chart-fallback { display: flex; align-items: center; justify-content: center; height: 100%; color: #a1a1aa; font-size: 0.85rem; text-align: center; padding: 1rem; }
        .pbp-timeline { position: relative; height: 56px; border-radius: 14px; border: 1px solid rgba(255,255,255,0.08); background: rgba(255,255,255,0.02); overflow: hidden; }
        .pbp-timeline-track { position: absolute; left: 16px; right: 16px; top: 50%; height: 2px; transform: translateY(-50%); background: rgba(255,255,255,0.12); }
        .pbp-marker { position: absolute; top: 50%; width: 10px; height: 10px; border-radius: 999px; transform: translate(-50%, -50%); border: 1px solid rgba(255,255,255,0.35); background: #71717a; cursor: pointer; transition: transform 0.15s ease, box-shadow 0.15s ease; }
        .pbp-marker:hover { transform: translate(-50%, -50%) scale(1.2); box-shadow: 0 0 0 4px rgba(255,255,255,0.08); }
        .pbp-marker.td { background: #22c55e; border-color: rgba(34,197,94,0.9); }
        .pbp-marker.turnover { background: #ef4444; border-color: rgba(239,68,68,0.9); }
        .pbp-marker.big { background: #f59e0b; border-color: rgba(245,158,11,0.9); }
        .pbp-marker.selected { box-shadow: 0 0 0 5px rgba(255,255,255,0.12); }
        .pbp-divider { position: absolute; top: 10px; bottom: 10px; width: 1px; background: rgba(255,255,255,0.16); }
        .pbp-divider-label { position: absolute; top: 8px; font-size: 0.62rem; color: #a1a1aa; transform: translateX(-50%); letter-spacing: 0.05em; }
        .pbp-table-head { border-bottom: 1px solid rgba(255,255,255,0.08); }
        .pbp-row { border-bottom: 1px solid rgba(255,255,255,0.05); }
        .pbp-row:last-child { border-bottom: none; }
        .pbp-row summary { list-style: none; }
        .pbp-row summary::-webkit-details-marker { display: none; }
        .pbp-row[open] { background: rgba(255,255,255,0.03); }
        .pbp-badge { display: inline-flex; align-items: center; gap: 0.25rem; padding: 0.15rem 0.45rem; border-radius: 999px; border: 1px solid rgba(255,255,255,0.12); font-size: 0.65rem; color: #e4e4e7; }
        .pbp-badge.td { border-color: rgba(34,197,94,0.45); color: #86efac; }
        .pbp-badge.turnover { border-color: rgba(239,68,68,0.45); color: #fca5a5; }
        .pbp-badge.big { border-color: rgba(245,158,11,0.45); color: #fcd34d; }
        .pbp-details-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 0.5rem 1.25rem; }
        @keyframes spin { from { transform: rotate(0); } to { transform: rotate(360deg); } }
        @keyframes shimmer { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; }
        .skip-link { position: absolute; left: -999px; top: 0.75rem; z-index: 60; padding: 0.5rem 0.75rem; background: #f97316; color: #09090b; border-radius: 999px; font-size: 0.75rem; font-weight: 700; text-decoration: none; }
        .skip-link:focus { left: 0.75rem; }
        :focus-visible { outline: 2px solid #f97316; outline-offset: 2px; }
        button:focus-visible, a:focus-visible, input:focus-visible, summary:focus-visible { outline: 2px solid #f97316; outline-offset: 2px; }
        body.modal-open { overflow: hidden; }
        .kbd-help-btn { position: fixed; bottom: 1rem; left: 1rem; z-index: 45; width: 36px; height: 36px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.08); color: #e4e4e7; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 0.9rem; transition: transform 0.2s ease, background 0.2s ease, border-color 0.2s ease; }
        .kbd-help-btn:hover { transform: translateY(-2px); background: rgba(255,255,255,0.16); border-color: rgba(255,255,255,0.35); }
        .kbd-modal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; z-index: 55; }
        .kbd-modal.open { display: flex; }
        .kbd-backdrop { position: absolute; inset: 0; background: rgba(9,9,11,0.72); backdrop-filter: blur(6px); }
        .kbd-dialog { position: relative; width: min(540px, 92vw); background: #0f0f13; border: 1px solid rgba(255,255,255,0.1); border-radius: 16px; padding: 1.25rem 1.25rem 1rem; box-shadow: 0 20px 40px rgba(0,0,0,0.5); }
        .kbd-dialog h2 { font-size: 1rem; font-weight: 700; color: #fafafa; margin-bottom: 0.75rem; }
        .kbd-list { display: grid; grid-template-columns: 1fr; gap: 0.5rem; }
        .kbd-item { display: flex; align-items: center; justify-content: space-between; padding: 0.5rem 0.75rem; border-radius: 10px; background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.06); font-size: 0.85rem; color: #d4d4d8; }
        .kbd-key { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 0.75rem; padding: 0.2rem 0.45rem; border-radius: 6px; background: rgba(255,255,255,0.12); color: #fafafa; border: 1px solid rgba(255,255,255,0.2); }
        .kbd-close { margin-top: 0.75rem; width: 100%; border-radius: 999px; padding: 0.5rem 0.75rem; font-size: 0.85rem; font-weight: 600; background: rgba(255,255,255,0.08); color: #f4f4f5; border: 1px solid rgba(255,255,255,0.12); }
        .kbd-close:hover { background: rgba(255,255,255,0.16); }
        :root { --touch-target: 44px; }
        #mainContent { scroll-margin-top: 6rem; }

        @media (max-width: 768px) {
            body { font-size: 16px; }
            .text-xs { font-size: 0.8125rem; }
            .text-sm { font-size: 0.9375rem; }
            .text-lg { font-size: 1.0625rem; }

            nav .max-w-7xl { padding-left: 1rem; padding-right: 1rem; }
            #filterBar { flex-wrap: wrap; gap: 0.5rem; justify-content: flex-end; }
            #filterBar span { display: none; }

            #tabNav { flex-wrap: wrap; overflow-x: visible; }
            #tabNav .nav-pill { flex: 1 1 calc(50% - 0.25rem); min-height: 44px; padding: 0.5rem 0.75rem; }
            #tabNav .nav-pill[data-tab="postturnovers"] { display: none; }

            #mainContent { padding-left: 1rem; padding-right: 1rem; }
            #mainContent .grid.grid-cols-2 { grid-template-columns: 1fr; }
            #mainContent .grid.grid-cols-3,
            #mainContent .grid.grid-cols-4 { grid-template-columns: repeat(2, minmax(0, 1fr)); }

            #mainContent table { display: block; overflow-x: auto; -webkit-overflow-scrolling: touch; width: 100%; }
            #mainContent table { min-width: 100%; }

            button, .filter-chip, .nav-pill, summary { min-height: 44px; }
            summary { display: flex; align-items: center; gap: 0.5rem; }

            .mobile-hide { display: none !important; }

            .team-header { flex-direction: column; gap: 0.75rem; }
            .team-header .text-right,
            .team-header .text-left { text-align: center; }
            .team-header h1 { font-size: 1.5rem; }
            .team-header .vs-badge { font-size: 1.75rem; }

            .pbp-details-grid { grid-template-columns: 1fr; }
        }

        @media (pointer: coarse) {
            button, .filter-chip, .nav-pill, summary, .menu-button, .menu-item, .kbd-help-btn, .collapsible-toggle { min-height: var(--touch-target); }
            .menu-button, .menu-item { padding-top: 0.6rem; padding-bottom: 0.6rem; }
            .filter-chip, .nav-pill, summary { padding-top: 0.5rem; padding-bottom: 0.5rem; }
            .kbd-help-btn { width: var(--touch-target); height: var(--touch-target); }
            .pbp-marker { width: var(--touch-target); height: var(--touch-target); background: transparent; border: none; }
            .pbp-marker::after { content: ""; position: absolute; left: 50%; top: 50%; width: 12px; height: 12px; border-radius: 999px; transform: translate(-50%, -50%); border: 1px solid rgba(255,255,255,0.35); background: #71717a; }
            .pbp-marker.td::after { background: #22c55e; border-color: rgba(34,197,94,0.9); }
            .pbp-marker.turnover::after { background: #ef4444; border-color: rgba(239,68,68,0.9); }
            .pbp-marker.big::after { background: #f59e0b; border-color: rgba(245,158,11,0.9); }
            .pbp-marker.selected::after { box-shadow: 0 0 0 5px rgba(255,255,255,0.12); }
        }

        @media print {
            @page { margin: 0.6in; }
            * { animation: none !important; transition: none !important; box-shadow: none !important; text-shadow: none !important; }
            body { background: #ffffff !important; color: #111111 !important; font-size: 11pt; line-height: 1.35; }
            nav, #tabNav, #filterBar, .mobile-hide, #kbdHelpBtn, #kbdModal { display: none !important; }
            main, .max-w-7xl { max-width: none !important; padding: 0 !important; }
            .section-enter { animation: none !important; }
            .glass, .zone-section, .team-a-bg, .team-b-bg { background: #ffffff !important; border-color: #d1d5db !important; }
            .zone-green, .zone-red, .zone-tight { background: none !important; border-left-color: #111111 !important; }
            .vs-badge { background: none !important; -webkit-text-fill-color: #111111 !important; color: #111111 !important; }
            .team-a, .team-b, .zone-title { color: #111111 !important; }
            .team-a-bar, .team-b-bar { background: #111111 !important; }
            .text-zinc-400, .text-zinc-500, .text-zinc-200 { color: #111111 !important; }
            .bg-zinc-900, .bg-white\\/5 { background: #ffffff !important; }
            .border-white\\/5, .border-white\\/10 { border-color: #d1d5db !important; }
            .sticky { position: static !important; }
            .collapsible-body { max-height: none !important; overflow: visible !important; }
            .collapsible-toggle { pointer-events: none !important; cursor: default !important; color: #111111 !important; background: none !important; border-bottom: 1px solid #d1d5db !important; }
            details { display: block !important; }
            details > summary { list-style: none; cursor: default !important; pointer-events: none !important; color: #111111 !important; }
            details > summary::-webkit-details-marker { display: none !important; }
            details:not([open]) > * { display: block !important; }
            details:not([open]) > summary { display: block !important; }
            table, thead, tbody, tfoot, tr, td, th, .glass, .zone-section, .stat-card, .collapsible-body, .print-section {
                break-inside: avoid !important;
                page-break-inside: avoid !important;
            }
            canvas, svg { filter: grayscale(1) contrast(1.1); }
            .print-section-title { font-size: 14pt; font-weight: 700; margin: 0 0 8px 0; }
            .print-section + .print-section { margin-top: 18px; }
            .text-xs { font-size: 9pt !important; }
            .text-sm { font-size: 10pt !important; }
            .text-lg { font-size: 12pt !important; }
            .text-2xl { font-size: 16pt !important; }
            .text-3xl { font-size: 18pt !important; }
            .text-4xl { font-size: 20pt !important; }
        }
    </style>
</head>
<body class="min-h-screen">
<a href="#mainContent" class="skip-link">Skip to content</a>
<div id="srAnnouncement" class="sr-only" aria-live="polite" aria-atomic="true"></div>

<!-- Top Bar -->
<nav class="fixed top-0 w-full z-50 border-b border-white/5 bg-[#09090b]/80 backdrop-blur-xl">
    <div class="max-w-7xl mx-auto px-6 h-14 flex items-center justify-between">
        <div class="flex items-center gap-3">
            <img src="assets/vt-logo-icon.png" alt="VT Sports Solutions" class="vt-logo-icon" style="height:32px">
            <span class="text-sm font-semibold text-zinc-200">Matchup Analysis</span>
            <span class="text-xs text-zinc-500 ml-1" id="buildVersion">__BUILD_VERSION__</span>
        </div>
        <div class="flex items-center gap-2">
            <div class="flex items-center gap-2" id="filterBar" role="toolbar" aria-label="Filters">
                <span class="text-xs text-zinc-500 mr-1">Filter:</span>
            </div>
            <div class="relative" id="exportMenu">
                <button class="menu-button" id="exportToggle" type="button" aria-haspopup="menu" aria-expanded="false" aria-label="Export menu">Export ‚ñæ</button>
                <div class="menu-panel hidden" id="exportPanel">
                    <button class="menu-item" type="button" onclick="exportCurrentViewPdf()">üñ®Ô∏è Export current view as PDF</button>
                    <button class="menu-item" type="button" onclick="exportCurrentTabCsv()">üìÑ Export current tab as CSV</button>
                    <button class="menu-item" type="button" onclick="downloadRawJson()">üóÇÔ∏è Export data.json</button>
                    <div class="menu-divider"></div>
                    <button class="menu-item" type="button" onclick="copyShareLink()">üîó Copy shareable link</button>
                </div>
            </div>
            <div class="relative" id="shareMenu">
                <button class="menu-button" id="shareToggle" type="button" aria-haspopup="menu" aria-expanded="false" aria-label="Share menu">Share</button>
                <div class="menu-panel hidden" id="sharePanel">
                    <button class="menu-item" type="button" onclick="copyShareLink()">üîó Copy link</button>
                    <button class="menu-item" type="button" onclick="shareToTwitter()">üê¶ Share on Twitter</button>
                    <button class="menu-item" type="button" onclick="shareViaEmail()">‚úâÔ∏è Share via email</button>
                </div>
            </div>
        </div>
    </div>
</nav>

<!-- Team Header -->
<div class="pt-20 pb-4 max-w-7xl mx-auto px-6">
    <div class="team-header flex items-center justify-center gap-6">
        <div class="text-right">
            <h1 class="text-3xl font-extrabold team-a" id="teamAName">Georgia</h1>
            <p class="text-sm text-zinc-400" id="teamARecord">12-1 ¬∑ SEC</p>
            <div class="mt-1 flex items-center justify-end gap-2">
                <span class="dq-tooltip" id="teamAQuality"></span>
            </div>
        </div>
        <div class="text-4xl font-black vs-badge">VS</div>
        <div class="text-left">
            <h1 class="text-3xl font-extrabold team-b" id="teamBName">Arizona State</h1>
            <p class="text-sm text-zinc-400" id="teamBRecord">5-7 ¬∑ Big 12</p>
            <div class="mt-1 flex items-center justify-start gap-2">
                <span class="dq-tooltip" id="teamBQuality"></span>
            </div>
        </div>
    </div>
</div>

<!-- Tab Navigation -->
<div class="sticky top-14 z-40 border-b border-white/5 bg-[#09090b]/90 backdrop-blur-xl">
    <div class="max-w-7xl mx-auto px-6 flex gap-1 overflow-x-auto py-2" id="tabNav" role="tablist" aria-label="Analysis sections"></div>
</div>

<!-- Main Content -->
<main class="max-w-7xl mx-auto px-6 py-6" id="mainContent" role="tabpanel" tabindex="-1"></main>

<button class="kbd-help-btn" id="kbdHelpBtn" aria-label="Keyboard shortcuts">?</button>
<div class="kbd-modal" id="kbdModal" role="dialog" aria-modal="true" aria-labelledby="kbdTitle" aria-hidden="true">
    <div class="kbd-backdrop" data-close="kbd"></div>
    <div class="kbd-dialog" role="document">
        <h2 id="kbdTitle">Keyboard shortcuts</h2>
        <div class="kbd-list">
            <div class="kbd-item"><span>Next/previous tab</span><span class="kbd-key">‚Üê / ‚Üí</span></div>
            <div class="kbd-item"><span>Jump to tab 1-9</span><span class="kbd-key">1-9</span></div>
            <div class="kbd-item"><span>Focus search (when available)</span><span class="kbd-key">/</span></div>
            <div class="kbd-item"><span>Close expanded sections</span><span class="kbd-key">Esc</span></div>
            <div class="kbd-item"><span>Show this help</span><span class="kbd-key">?</span></div>
        </div>
        <button class="kbd-close" id="kbdCloseBtn">Close</button>
    </div>
</div>

<script>
let DATA = null;
let currentTab = 'overview';
let currentFilter = 'all';
let allPlaysQuery = '';
let allPlaysFilters = { team: 'all', type: 'all', scoring: false, turnover: false };
let allPlaysSelected = null;

const TABS = [
    { id: 'overview', label: 'Overview', icon: 'üìä' },
    { id: 'middle8', label: 'Middle 8', icon: '‚è±Ô∏è' },
    { id: 'explosives', label: 'Explosive Plays', icon: 'üí•' },
    { id: 'redzone', label: 'Red Zone', icon: 'üî¥' },
    { id: 'penalties', label: 'Penalties', icon: 'üö©' },
    { id: '4thdown', label: '4th Down', icon: 'üéØ' },
    { id: 'turnovers', label: 'Turnovers', icon: 'üîÑ' },
    { id: 'postturnovers', label: 'Post-Turnover', icon: 'üîÑ' },
    { id: 'specialteams', label: 'Special Teams', icon: 'üèà' },
    { id: 'glossary', label: 'Glossary', icon: 'üìñ' },
    { id: 'allplays', label: 'All Plays', icon: 'üìã' },
];

const TAB_TITLES = {
    overview: 'Overview',
    trends: 'Trends',
    middle8: 'Middle 8',
    explosives: 'Explosive Plays',
    redzone: 'Red Zone',
    penalties: 'Penalties',
    '4thdown': '4th Down',
    turnovers: 'Turnovers',
    postturnovers: 'Post-Turnover',
    specialteams: 'Special Teams',
    glossary: 'Glossary',
    allplays: 'All Plays',
};

const FILTERS = [
    { id: 'all', label: 'All Games' },
    { id: 'conf', label: 'Conference' },
    { id: 'nonconf', label: 'Non-Conference' },
    { id: 'power4', label: 'Power 4' },
    { id: 'last3', label: 'Last 3' },
];
const FILTER_TO_SPLIT = { all: 'all', conf: 'conf', nonconf: 'nonconf', power4: 'all', last3: 'all' };

function getTabTitle(id) {
    return TAB_TITLES[id] || TABS.find(t => t.id === id)?.label || 'Tab';
}

function updateTabTitle(id) {
    const title = getTabTitle(id);
    const tabHeader = document.getElementById('tabTitle');
    if (tabHeader) tabHeader.textContent = title;
    return title;
}

function getShareParams() {
    const params = new URLSearchParams();
    params.set('tab', currentTab);
    params.set('filter', currentFilter);
    return params;
}

function buildShareUrl() {
    const base = window.location.href.split('#')[0];
    return `${base}#${getShareParams().toString()}`;
}

function applyHashState() {
    if (!window.location.hash) return;
    const raw = window.location.hash.replace(/^#/, '');
    const params = new URLSearchParams(raw);
    const tab = params.get('tab');
    const filter = params.get('filter');
    if (tab && TABS.some(t => t.id === tab)) currentTab = tab;
    if (filter && FILTERS.some(f => f.id === filter)) currentFilter = filter;
}

function updateHashState() {
    const hash = getShareParams().toString();
    if (window.location.hash.replace(/^#/, '') === hash) return;
    window.history.replaceState(null, '', `#${hash}`);
}

function filterGames(games) {
    switch(currentFilter) {
        case 'conf': return games.filter(g => g.conference);
        case 'nonconf': return games.filter(g => !g.conference);
        case 'power4': return games.filter(g => g.is_power4);
        case 'last3': return games.slice(-3);
        default: return games;
    }
}

function agg(games) {
    const n = games.length || 1;
    const pf = games.reduce((s,g) => s + g.points_for, 0);
    const pa = games.reduce((s,g) => s + g.points_against, 0);
    const wins = games.filter(g => g.points_for > g.points_against).length;
    const losses = n - wins;
    const expl = games.reduce((s,g) => s + g.explosives, 0);
    const pen = games.reduce((s,g) => s + g.penalties, 0);
    const tof = games.reduce((s,g) => s + g.turnovers_gained, 0);
    const tol = games.reduce((s,g) => s + g.turnovers_lost, 0);
    const rzt = games.reduce((s,g) => s + g.red_zone_trips, 0);
    const rztd = games.reduce((s,g) => s + g.red_zone_tds, 0);
    const rzfg = games.reduce((s,g) => s + g.red_zone_fgs, 0);
    
    // New zone stats
    const green_zone_trips = games.reduce((s,g) => s + (g.green_zone_trips || 0), 0);
    const green_zone_tds = games.reduce((s,g) => s + (g.green_zone_tds || 0), 0);
    const green_zone_fgs = games.reduce((s,g) => s + (g.green_zone_fgs || 0), 0);
    const green_zone_failed = games.reduce((s,g) => s + (g.green_zone_failed || 0), 0);
    
    const tight_red_zone_trips = games.reduce((s,g) => s + (g.tight_red_zone_trips || 0), 0);
    const tight_red_zone_tds = games.reduce((s,g) => s + (g.tight_red_zone_tds || 0), 0);
    const tight_red_zone_fgs = games.reduce((s,g) => s + (g.tight_red_zone_fgs || 0), 0);
    const tight_red_zone_failed = games.reduce((s,g) => s + (g.tight_red_zone_failed || 0), 0);
    
    return {
        games: n, wins, losses, record: `${wins}-${losses}`,
        pf, pa, ppg: (pf/n).toFixed(1), oppg: (pa/n).toFixed(1),
        expl, explpg: (expl/n).toFixed(1),
        pen, penpg: (pen/n).toFixed(1),
        tof, tol, tom: tof - tol,
        rzt, rztd, rzfg,
        rzpct: rzt ? ((rztd+rzfg)/rzt*100).toFixed(1) : '0',
        rztdpct: rzt ? (rztd/rzt*100).toFixed(1) : '0',
        green_zone_trips, green_zone_tds, green_zone_fgs, green_zone_failed,
        red_zone_trips: rzt, red_zone_tds: rztd, red_zone_fgs: rzfg,
        tight_red_zone_trips, tight_red_zone_tds, tight_red_zone_fgs, tight_red_zone_failed,
    };
}

function average(values) {
    const nums = values.filter(v => typeof v === 'number' && !Number.isNaN(v));
    if (!nums.length) return null;
    return nums.reduce((s, v) => s + v, 0) / nums.length;
}

function stddev(values) {
    const mean = average(values);
    if (mean === null) return null;
    const nums = values.filter(v => typeof v === 'number' && !Number.isNaN(v));
    if (nums.length < 2) return 0;
    const variance = nums.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / (nums.length - 1);
    return Math.sqrt(variance);
}

function findOutliers(values, threshold = 1.7, limit = 2) {
    const mean = average(values);
    const sd = stddev(values);
    if (mean === null || sd === null || sd === 0) return [];
    const outliers = [];
    values.forEach((v, i) => {
        if (typeof v !== 'number' || Number.isNaN(v)) return;
        const z = (v - mean) / sd;
        if (Math.abs(z) >= threshold) outliers.push({ index: i, value: v, z });
    });
    outliers.sort((a, b) => Math.abs(b.z) - Math.abs(a.z));
    return outliers.slice(0, limit);
}

function formatSigned(value, digits = 1) {
    if (value === null || value === undefined || Number.isNaN(value)) return '‚Äî';
    const sign = value > 0 ? '+' : '';
    return `${sign}${value.toFixed(digits)}`;
}

function formatPct(value) {
    if (value === null || value === undefined || Number.isNaN(value)) return '‚Äî';
    return `${value.toFixed(1)}%`;
}

function gameLabel(game, index) {
    if (!game) return `G${index + 1}`;
    const date = game.date ? ` (${game.date})` : '';
    return `G${index + 1} vs ${game.opponent}${date}`;
}

function lastN(games, n) {
    if (!games.length) return [];
    return games.slice(Math.max(games.length - n, 0));
}

function calcRzPct(game) {
    if (!game || !game.red_zone_trips) return null;
    return ((game.red_zone_tds + game.red_zone_fgs) / game.red_zone_trips) * 100;
}

function trendDelta(games, extractor, n = 3) {
    const season = average(games.map(extractor));
    const recentGames = lastN(games, n);
    const recent = average(recentGames.map(extractor));
    if (season === null || recent === null) return null;
    return { season, recent, delta: recent - season, span: recentGames.length };
}

function bestWorstPerformances(games) {
    if (!games.length) return { best: null, worst: null };
    const margins = games.map(g => g.points_for - g.points_against);
    let bestIdx = 0;
    let worstIdx = 0;
    margins.forEach((m, i) => {
        if (m > margins[bestIdx]) bestIdx = i;
        if (m < margins[worstIdx]) worstIdx = i;
    });
    return { best: { index: bestIdx, margin: margins[bestIdx] }, worst: { index: worstIdx, margin: margins[worstIdx] } };
}

function weekOverWeekSummary(games) {
    if (games.length < 2) return null;
    const latest = games[games.length - 1];
    const prev = games[games.length - 2];
    const toMargin = g => g.turnovers_gained - g.turnovers_lost;
    return {
        latest,
        prev,
        deltas: {
            points_for: latest.points_for - prev.points_for,
            points_against: latest.points_against - prev.points_against,
            margin: (latest.points_for - latest.points_against) - (prev.points_for - prev.points_against),
            explosives: latest.explosives - prev.explosives,
            tom: toMargin(latest) - toMargin(prev),
            rz: (calcRzPct(latest) ?? 0) - (calcRzPct(prev) ?? 0),
            penalties: latest.penalties - prev.penalties,
        }
    };
}

function buildNotableStats(games) {
    const notable = [];
    if (!games.length) return notable;
    const last5 = lastN(games, 5);
    const last3 = lastN(games, 3);
    if (last5.length >= 3) {
        const scored30 = last5.filter(g => g.points_for >= 30).length;
        notable.push(`Scored 30+ in ${scored30}/${last5.length} recent games.`);
        const allowed20 = last5.filter(g => g.points_against <= 20).length;
        notable.push(`Held opponents to ‚â§20 in ${allowed20}/${last5.length} recent games.`);
    }
    const zeroTO = last5.filter(g => g.turnovers_lost === 0).length;
    if (last5.length) notable.push(`Zero-turnover outings: ${zeroTO}/${last5.length} recently.`);
    const explSeason = average(games.map(g => g.explosives));
    const explRecent = average(last3.map(g => g.explosives));
    if (explSeason !== null && explRecent !== null) {
        const delta = explRecent - explSeason;
        const direction = delta >= 0 ? 'up' : 'down';
        notable.push(`Explosives trend ${direction}: ${explRecent.toFixed(1)} last 3 vs ${explSeason.toFixed(1)} season.`);
    }
    const rzSeason = average(games.map(calcRzPct));
    const rzRecent = average(last3.map(calcRzPct));
    if (rzSeason !== null && rzRecent !== null) {
        const delta = rzRecent - rzSeason;
        const direction = delta >= 0 ? 'up' : 'down';
        notable.push(`Red zone finish ${direction}: ${formatPct(rzRecent)} last 3 vs ${formatPct(rzSeason)} season.`);
    }
    return notable.slice(0, 4);
}

function buildOutlierNotes(games, label, extractor) {
    const values = games.map(extractor);
    const outliers = findOutliers(values, 1.7, 2);
    return outliers.map(o => ({
        label,
        index: o.index,
        value: o.value,
        z: o.z,
        game: games[o.index],
    }));
}

const EXPECTED_GAME_PATHS = [
    'conference', 'date', 'game_number', 'opponent', 'opponent_abbr', 'is_power4',
    'points_for', 'points_against', 'explosives', 'explosive_rushes', 'explosive_passes', 'explosive_details',
    'penalties', 'penalty_details',
    'turnovers_gained', 'turnovers_lost', 'interceptions_gained', 'interceptions_lost', 'fumbles_gained', 'fumbles_lost',
    'red_zone_trips', 'red_zone_tds', 'red_zone_fgs', 'red_zone_plays',
    'green_zone_trips', 'green_zone_tds', 'green_zone_fgs', 'green_zone_failed',
    'tight_red_zone_trips', 'tight_red_zone_tds', 'tight_red_zone_fgs', 'tight_red_zone_failed',
    'middle8_points_for', 'middle8_points_against', 'middle8_scoring_plays',
    'post_turnover_drives', 'points_off_turnovers_for', 'points_off_turnovers_against',
    '4th_down_attempts', '4th_down_conversions',
    'play_tree',
    'special_teams.punts', 'special_teams.punt_yards', 'special_teams.punt_net_yards',
    'special_teams.punt_long', 'special_teams.punts_inside_20', 'special_teams.punt_touchbacks',
    'special_teams.field_goals_made', 'special_teams.field_goals_attempts', 'special_teams.field_goal_long',
    'special_teams.kick_return_30_plus', 'special_teams.punt_return_20_plus',
    'special_teams.special_teams_tds', 'special_teams.fg_blocks', 'special_teams.punt_blocks',
];

function hasPath(obj, path) {
    const parts = path.split('.');
    let cur = obj;
    for (const part of parts) {
        if (!cur || !Object.prototype.hasOwnProperty.call(cur, part)) return false;
        cur = cur[part];
    }
    return true;
}

function computeFieldQuality(games, fields) {
    const total = (games.length || 0) * (fields.length || 0);
    if (!total) return { pct: 0, present: 0, total: 0, missing: [], missingCounts: {} };
    let present = 0;
    const missingCounts = {};
    games.forEach(g => {
        fields.forEach(field => {
            if (hasPath(g, field)) {
                present += 1;
            } else {
                missingCounts[field] = (missingCounts[field] || 0) + 1;
            }
        });
    });
    const pct = Math.round((present / total) * 100);
    return { pct, present, total, missing: Object.keys(missingCounts), missingCounts };
}

function qualityClass(pct) {
    if (pct === null || pct === undefined) return 'dq-neutral';
    if (pct >= 90) return 'dq-green';
    if (pct >= 70) return 'dq-yellow';
    return 'dq-red';
}

function qualityLabel(pct) {
    if (pct === null || pct === undefined) return 'Unknown';
    if (pct >= 90) return 'Complete';
    if (pct >= 70) return 'Partial';
    return 'Sparse';
}

function formatFieldLabel(field) {
    if (!field) return '';
    return field.replace('special_teams.', 'ST ').replace(/_/g, ' ');
}

function summarizeMissing(missingCounts, limit = 3) {
    const entries = Object.entries(missingCounts).sort((a,b) => b[1] - a[1]);
    return entries.slice(0, limit).map(([field, count]) => `${formatFieldLabel(field)} (${count})`);
}

function buildQuality(games, fields, label, note) {
    if (!fields || !fields.length) {
        return { pct: null, present: 0, total: 0, missing: [], missingCounts: {}, label, note: note || 'Not tracked' };
    }
    const q = computeFieldQuality(games, fields);
    return { ...q, label, note };
}

function makeQuality(games) {
    return (fields, label, note) => buildQuality(games, fields, label, note);
}

function qualityTooltipHtml(title, quality) {
    const pct = quality.pct === null ? '‚Äî' : `${quality.pct}%`;
    const label = qualityLabel(quality.pct);
    const missingSummary = quality.missing.length ? `Missing: ${summarizeMissing(quality.missingCounts, 4).join(', ')}` : 'No missing fields detected.';
    const note = quality.note ? `<div class="text-xs text-zinc-500 mt-1">${quality.note}</div>` : '';
    return `
        <div class="text-xs font-semibold text-white mb-1">${title}</div>
        <div class="text-xs text-zinc-300">Completeness: ${pct} - ${label}</div>
        <div class="text-xs text-zinc-400 mt-1">${missingSummary}</div>
        ${note}
    `;
}

function qualityInfoIcon(title, quality) {
    const cls = qualityClass(quality.pct);
    return `<span class="dq-tooltip dq-info ${cls}">
        <span class="dq-icon">i</span>
        <span class="dq-tooltip-content">${qualityTooltipHtml(title, quality)}</span>
    </span>`;
}

function qualityWarningIcon(title, quality) {
    if (!quality.missing || !quality.missing.length) return '';
    const cls = qualityClass(quality.pct);
    return `<span class="dq-tooltip dq-warning ${cls}">
        !
        <span class="dq-tooltip-content">${qualityTooltipHtml(`${title} (incomplete)`, quality)}</span>
    </span>`;
}

function qualityBadge(quality, label = 'Data') {
    const cls = qualityClass(quality.pct);
    const pct = quality.pct === null ? '‚Äî' : `${quality.pct}%`;
    return `<span class="dq-badge ${cls}">${label} ${pct}</span>`;
}

function computeTeamQuality(games) {
    return buildQuality(games, EXPECTED_GAME_PATHS, 'Overall data');
}

function computeOutlierMap(games, fields = ['points_for', 'points_against', 'explosives'], threshold = 2) {
    const stats = {};
    fields.forEach(field => {
        const vals = games.map(g => (hasPath(g, field) ? g[field] : null)).filter(v => Number.isFinite(v));
        const mean = vals.length ? vals.reduce((s,v) => s + v, 0) / vals.length : 0;
        const variance = vals.length > 1 ? vals.reduce((s,v) => s + Math.pow(v - mean, 2), 0) / vals.length : 0;
        const stdev = Math.sqrt(variance);
        stats[field] = { mean, stdev };
    });
    const outliers = {};
    games.forEach((g, idx) => {
        const key = g.game_number || (idx + 1);
        fields.forEach(field => {
            const { mean, stdev } = stats[field];
            if (!stdev || !hasPath(g, field)) return;
            const val = g[field];
            if (!Number.isFinite(val)) return;
            const z = (val - mean) / stdev;
            if (Math.abs(z) >= threshold) {
                const label = `${formatFieldLabel(field)} ${val} (${z.toFixed(1)} sd)`;
                if (!outliers[key]) outliers[key] = [];
                outliers[key].push(label);
            }
        });
    });
    return outliers;
}

function renderQualityScoreCard(ga, aa, gQuality, aQuality) {
    const gMissing = gQuality.missing.length ? `Missing: ${summarizeMissing(gQuality.missingCounts, 5).join(', ')}` : 'No missing fields detected.';
    const aMissing = aQuality.missing.length ? `Missing: ${summarizeMissing(aQuality.missingCounts, 5).join(', ')}` : 'No missing fields detected.';
    return `<div class="glass rounded-xl p-4 mb-6">
        <div class="flex items-center justify-between mb-3">
            <div class="text-sm font-semibold text-white">Data quality</div>
            <div class="text-xs text-zinc-500">Completeness vs expected fields</div>
        </div>
        <div class="grid grid-cols-2 gap-4">
            <div class="rounded-lg border border-white/5 p-3">
                <div class="flex items-center justify-between">
                    <span class="text-sm font-medium team-a">${ga.name}</span>
                    ${qualityBadge(gQuality, 'Data')}
                </div>
                <div class="text-xs text-zinc-500 mt-2">${gMissing}</div>
            </div>
            <div class="rounded-lg border border-white/5 p-3">
                <div class="flex items-center justify-between">
                    <span class="text-sm font-medium team-b">${aa.name}</span>
                    ${qualityBadge(aQuality, 'Data')}
                </div>
                <div class="text-xs text-zinc-500 mt-2">${aMissing}</div>
            </div>
        </div>
    </div>`;
}

function sumField(games, field) {
    return games.reduce((s,g) => s + (g[field] || 0), 0);
}

function sumPostTurnoverPoints(game, type, teamAbbr) {
    const drives = (game && game.post_turnover_drives) || [];
    return drives.reduce((s,d) => {
        if (teamAbbr && d.recovered_by !== teamAbbr) {
            return s;
        }
        if (!type || d.turnover_type === type) {
            return s + (d.points_scored || 0);
        }
        return s;
    }, 0);
}

function sumPostTurnoverPointsByType(games, type, teamAbbr) {
    return games.reduce((s,g) => s + sumPostTurnoverPoints(g, type, teamAbbr), 0);
}

function sumSpecial(games, field) {
    return games.reduce((s,g) => s + ((g.special_teams && g.special_teams[field]) || 0), 0);
}

function maxSpecial(games, field) {
    return games.reduce((m,g) => Math.max(m, (g.special_teams && g.special_teams[field]) || 0), 0);
}

function normalizePlayerName(raw) {
    if (!raw || typeof raw !== 'string') return '';
    let name = raw.trim().replace(/\s+/g, ' ');
    name = name.replace(/^[A-Z]{2,4}\s+/, '');
    if (name.includes(',')) {
        const [last, first] = name.split(',').map(s => s.trim()).filter(Boolean);
        if (first && last) return `${first} ${last}`.trim();
    }
    return name;
}

const EXPLOSIVE_NAME_PATTERN = "[A-Za-z][A-Za-z.'-]*(?:\\s+[A-Za-z][A-Za-z.'-]*)*(?:\\s+Jr\\.)?(?:\\s+III|\\s+II|\\s+IV)?\\s*,\\s*[A-Za-z0-9.'-]+(?:\\s+[A-Za-z0-9.'-]+)?";
const EXPLOSIVE_PASS_RE = new RegExp(`\\bto\\s+(${EXPLOSIVE_NAME_PATTERN})`, 'i');
const EXPLOSIVE_RUSH_RE = new RegExp(`(${EXPLOSIVE_NAME_PATTERN})\\s+(?:rush|run)\\b`, 'i');

function extractExplosivePlayer(desc, playType) {
    if (!desc || typeof desc !== 'string') return '';
    const source = desc.replace(/\s+/g, ' ').trim();
    if (playType === 'pass') {
        const m = source.match(EXPLOSIVE_PASS_RE);
        return m ? normalizePlayerName(m[1]) : '';
    }
    const m = source.match(EXPLOSIVE_RUSH_RE);
    return m ? normalizePlayerName(m[1]) : '';
}

function buildExplosiveLeaders(games) {
    const players = new Map();
    games.forEach(g => {
        (g.explosive_details || []).forEach(e => {
            const name = (e.player && normalizePlayerName(e.player)) || extractExplosivePlayer(e.description || '', e.type || '');
            if (!name) return;
            if (!players.has(name)) {
                players.set(name, { name, rush: 0, pass: 0, rushMax: 0, passMax: 0, totalYards: 0 });
            }
            const entry = players.get(name);
            const yards = Number.isFinite(e.yards) ? e.yards : 0;
            if (e.type === 'rush') {
                entry.rush += 1;
                entry.rushMax = Math.max(entry.rushMax, yards);
            } else {
                entry.pass += 1;
                entry.passMax = Math.max(entry.passMax, yards);
            }
            entry.totalYards += yards;
        });
    });
    return Array.from(players.values())
        .map(p => ({ ...p, total: p.rush + p.pass }))
        .sort((a, b) => (b.total - a.total) || (b.totalYards - a.totalYards) || a.name.localeCompare(b.name))
        .slice(0, 5);
}

function renderExplosiveLeaders(title, leaders, teamClass) {
    if (!leaders.length) {
        return `<div class="glass rounded-xl p-4">
            <div class="text-sm text-zinc-300 font-medium mb-2">${title}</div>
            <div class="text-xs text-zinc-500">No explosive play player data found.</div>
        </div>`;
    }
    const fmt = (n) => n ? `${n}+ yards` : '‚Äî';
    const formatExplosiveLine = (player) => {
        const parts = [];
        if (player.rush > 0) {
            parts.push(`${player.rush} rush explosives (${fmt(player.rushMax)})`);
        }
        if (player.pass > 0) {
            parts.push(`${player.pass} pass explosives (${fmt(player.passMax)})`);
        }
        return parts.length ? parts.join(', ') : 'No explosives';
    };
    return `<div class="glass rounded-xl p-4">
        <div class="flex items-center justify-between mb-3">
            <div class="text-sm text-zinc-300 font-medium">${title}</div>
            <div class="text-xs text-zinc-500">Top 5 players</div>
        </div>
        <div class="space-y-2 text-xs">
            ${leaders.map(p => `
                <div class="flex items-start justify-between gap-3 border-b border-white/5 pb-2 last:border-b-0 last:pb-0">
                    <div class="font-semibold ${teamClass}">${p.name}</div>
                    <div class="text-zinc-400 text-right">
                        ${formatExplosiveLine(p)}
                    </div>
                </div>
            `).join('')}
        </div>
    </div>`;
}

function getTurnoverType(desc) {
    if (!desc || typeof desc !== 'string') return '';
    const upper = desc.toUpperCase();
    if (upper.includes('INTERCEPT')) return 'INT';
    if (upper.includes('FUMBLE') || upper.includes('FUMBLED')) return 'FUM';
    return '';
}

function buildTurnoverTypeLookup(game) {
    const lookup = {};
    (game.post_turnover_drives || []).forEach(d => {
        if (d.turnover_description && d.turnover_type) {
            lookup[d.turnover_description] = d.turnover_type;
        }
    });
    return lookup;
}

function resolveTurnoverType(play, lookup) {
    if (play && play.turnover_type) return play.turnover_type;
    if (lookup && play && play.description && lookup[play.description]) return lookup[play.description];
    return getTurnoverType(play && play.description ? play.description : '');
}

function extractTurnoverPlaymaker(desc) {
    if (!desc || typeof desc !== 'string') return '';
    const type = getTurnoverType(desc);
    let match = null;
    if (type === 'INT') {
        match = desc.match(/intercepted by (.+?)(?: at | return |,|\.|$)/i);
    } else if (type === 'FUM') {
        match = desc.match(/recovered by (.+?)(?: at |,|\.|$)/i);
        if (!match || !match[1]) {
            match = desc.match(/forced by (.+?)(?: recovered| at |,|\.|$)/i);
        }
    }
    if (!match || !match[1]) return '';
    return normalizePlayerName(match[1]);
}

function compBar(label, valA, valB, unit='') {
    const max = Math.max(valA, valB, 1);
    const pctA = (valA/max*100).toFixed(0);
    const pctB = (valB/max*100).toFixed(0);
    return `
    <div class="glass rounded-xl p-4 mb-3">
        <div class="text-xs text-zinc-500 mb-2 text-center">${label}</div>
        <div class="flex items-center gap-3">
            <span class="text-sm font-bold team-a w-16 text-right">${valA}${unit}</span>
            <div class="flex-1 flex gap-1 h-6">
                <div class="flex-1 flex justify-end"><div class="team-a-bar rounded-l-md h-full" style="width:${pctA}%"></div></div>
                <div class="flex-1"><div class="team-b-bar rounded-r-md h-full" style="width:${pctB}%"></div></div>
            </div>
            <span class="text-sm font-bold team-b w-16">${valB}${unit}</span>
        </div>
    </div>`;
}

function ordinal(n) {
    const num = Number(n);
    if (!Number.isFinite(num)) return '';
    const mod100 = num % 100;
    if (mod100 >= 11 && mod100 <= 13) return `${num}th`;
    const mod10 = num % 10;
    const suffix = mod10 === 1 ? 'st' : (mod10 === 2 ? 'nd' : (mod10 === 3 ? 'rd' : 'th'));
    return `${num}${suffix}`;
}

function renderStatBadge(rank, total, reverse=false, conference='') {
    if (!rank || !total) return '';
    const adjustedRank = reverse ? (total - rank + 1) : rank;
    let cls = 'mid';
    if (adjustedRank <= 3) cls = 'good';
    else if (adjustedRank > Math.ceil(total * 0.75)) cls = 'bad';
    else if (adjustedRank > Math.ceil(total * 0.5)) cls = 'low';
    const confLabel = conference ? ` in ${conference}` : '';
    return `<span class="rank-badge ${cls}">${ordinal(adjustedRank)}${confLabel}</span>`;
}

const RANKING_META = {
    fourth_down: { reverse: false },
    turnover_margin: { reverse: false },
    penalties: { reverse: true },
    time_of_possession: { reverse: false },
    sacks_offense: { reverse: true },
    sacks_defense: { reverse: false },
    total_offense: { reverse: false },
    total_defense: { reverse: true },
    rushing_offense: { reverse: false },
    rushing_defense: { reverse: true },
    passing_offense: { reverse: false },
    passing_defense: { reverse: true },
    scoring_margin: { reverse: false },
    scoring_offense: { reverse: false },
    scoring_defense: { reverse: true },
    third_down: { reverse: false },
    red_zone: { reverse: false },
    explosives: { reverse: false },
};

function getRanking(team, key) {
    if (!team || !team.cfbstats || !team.cfbstats.rankings) return null;
    const rankings = team.cfbstats.rankings;
    if ('all' in rankings) {
        const split = FILTER_TO_SPLIT[currentFilter] || 'all';
        return (rankings[split] && rankings[split][key]) || null;
    }
    return rankings[key] || null;
}

function buildStatBadge(team, key) {
    const entry = getRanking(team, key);
    if (!entry) return '';
    const meta = RANKING_META[key] || {};
    return renderStatBadge(entry.rank, entry.total, !!meta.reverse, entry.conference);
}

function formatRankingLabel(entry) {
    if (!entry) return '';
    const value = entry.value ? ` (${entry.value})` : '';
    const label = entry.label ? ` in ${entry.label}` : '';
    const conf = entry.conference ? ` in ${entry.conference}` : '';
    return `${ordinal(entry.rank)}${conf}${label}${value}`;
}

function statCard(label, value, sub, teamClass, quality, badge='') {
    const showQuality = quality !== null && quality !== undefined;
    const infoQuality = showQuality ? (quality || { pct: null, missing: [], missingCounts: {}, label, note: 'Quality not available' }) : null;
    const infoIcon = showQuality ? qualityInfoIcon(`${label} data`, infoQuality) : '';
    const warningIcon = showQuality && quality ? qualityWarningIcon(`${label} data`, quality) : '';
    return `<div class="stat-card glass rounded-xl p-4 text-center">
        <div class="text-xs text-zinc-500 flex items-center justify-center gap-1">
            <span>${label}</span>${warningIcon}${infoIcon}
        </div>
        <div class="text-2xl font-bold ${teamClass} mt-1 flex items-center justify-center gap-2">
            <span>${value}</span>
            ${badge || ''}
        </div>
        ${sub ? `<div class="text-xs text-zinc-500 mt-1">${sub}</div>` : ''}
    </div>`;
}

function statCardWithBreakdown(label, value, sub, teamClass, quality, rows, emptyNote='No plays recorded.') {
    const showQuality = quality !== null && quality !== undefined;
    const infoQuality = showQuality ? (quality || { pct: null, missing: [], missingCounts: {}, label, note: 'Quality not available' }) : null;
    const infoIcon = showQuality ? qualityInfoIcon(`${label} data`, infoQuality) : '';
    const warningIcon = showQuality && quality ? qualityWarningIcon(`${label} data`, quality) : '';
    const detailsBody = rows && rows.length ? `
        <div class="mt-2 space-y-1 text-zinc-400">
            ${rows.map(r => {
                const opp = formatOpponentLabel(r.opponent, r.opponent_abbr);
                const date = formatGameDate(r.date);
                const meta = [opp, date ? `(${date})` : ''].filter(Boolean).join(' ');
                return `<div class="flex items-center justify-between"><span>G${r.game_number} ${meta}</span><span class="text-zinc-200">${r.value}</span></div>`;
            }).join('')}
        </div>` : `<div class="mt-2 text-zinc-500">${emptyNote}</div>`;
    const details = `
        <details class="mt-2 text-left text-xs text-zinc-500">
            <summary class="cursor-pointer hover:text-zinc-300">Breakdown by game</summary>
            ${detailsBody}
        </details>`;
    return `<div class="stat-card glass rounded-xl p-4 text-center">
        <div class="text-xs text-zinc-500 flex items-center justify-center gap-1">
            <span>${label}</span>${warningIcon}${infoIcon}
        </div>
        <div class="text-2xl font-bold ${teamClass} mt-1">${value}</div>
        ${sub ? `<div class="text-xs text-zinc-500 mt-1">${sub}</div>` : ''}
        ${details}
    </div>`;
}

function renderContextBadges(team, badgeClass, badgeKey, emptyText = 'No conference context available.') {
    const entry = getRanking(team, badgeKey);
    const badges = entry ? (Array.isArray(entry) ? entry : [entry]) : [];
    if (!badges.length) {
        return `<div class="text-zinc-500 text-xs">${emptyText}</div>`;
    }
    return `<div class="flex flex-wrap gap-2">${badges.map(b => `<span class="context-badge ${badgeClass}">${formatRankingLabel(b)}</span>`).join('')}</div>`;
}

function renderContextBadgeGroup(team, badgeClass, badgeKeys, emptyText) {
    const badges = badgeKeys.flatMap(key => {
        const entry = getRanking(team, key);
        if (!entry) return [];
        return Array.isArray(entry) ? entry : [entry];
    });
    if (!badges.length) {
        return `<div class="text-zinc-500 text-xs">${emptyText}</div>`;
    }
    return `<div class="flex flex-wrap gap-2">${badges.map(b => `<span class="context-badge ${badgeClass}">${formatRankingLabel(b)}</span>`).join('')}</div>`;
}

function classifyRedZoneFailure(play) {
    const result = (play.drive_result || '').toUpperCase();
    const desc = (play.description || '').toUpperCase();
    const fgHint = desc.includes('FIELD GOAL') || /\bFG\b/.test(desc) || result.includes('FG');
    const missedFg = result.includes('MISSED_FG') || (fgHint && (
        desc.includes('NO GOOD') || desc.includes('MISSED') || desc.includes('BLOCKED') || desc.includes('WIDE')
    ));
    if (result.includes('DOWNS') || desc.includes('TURNOVER ON DOWNS')) return 'downs';
    if (missedFg) return 'missed_fg';
    if (result.includes('TURNOVER') || result.includes('INT') || result.includes('FUM') ||
        desc.includes('INTERCEPT') || desc.includes('PICKED OFF') || desc.includes('FUMBLE') ||
        desc.includes('FUMBLED') || desc.includes('RECOVERED BY')) return 'turnover';
    if (result.includes('END') || result.includes('HALF') || result.includes('GAME') || result.includes('TIME EXPIRED') ||
        desc.includes('END OF HALF') || desc.includes('END OF GAME') || desc.includes('TIME EXPIRED') ||
        desc.includes('END OF 1ST') || desc.includes('END OF 2ND') || desc.includes('END OF 3RD') || desc.includes('END OF 4TH')) {
        return 'end_half_game';
    }
    return null;
}

function computeFailedBreakdown(games, zoneKey) {
    const breakdown = { turnover: 0, downs: 0, end_half_game: 0, missed_fg: 0 };
    const seenDrives = new Set();
    games.forEach(g => {
        const plays = (g.red_zone_plays || []).filter(p => {
            if (zoneKey === 'green_zone') return p.yards_to_goal <= 30;
            if (zoneKey === 'red_zone') return p.yards_to_goal <= 20;
            if (zoneKey === 'tight_red_zone') return p.yards_to_goal <= 10;
            return false;
        });
        plays.forEach(p => {
            if (p.scoring) return;
            const kind = classifyRedZoneFailure(p);
            if (!kind) return;
            const driveKey = (p.drive_id !== undefined && p.drive_id !== null)
                ? `${g.game_number || ''}-${p.drive_id}`
                : `${g.game_number || ''}-${p.quarter || ''}-${p.clock || ''}-${p.description || ''}`;
            if (seenDrives.has(driveKey)) return;
            seenDrives.add(driveKey);
            breakdown[kind] += 1;
        });
    });
    return breakdown;
}

function failedStatCard(value, teamClass, breakdown, quality) {
    const total = Object.values(breakdown || {}).reduce((s,v) => s + v, 0);
    const details = total ? `
        <details class="mt-2 text-left text-xs text-zinc-500">
            <summary class="cursor-pointer hover:text-zinc-300">Breakdown</summary>
            <div class="mt-2 space-y-1 text-zinc-400">
                <div class="flex items-center justify-between"><span>Turnovers</span><span class="text-zinc-200">${breakdown.turnover}</span></div>
                <div class="flex items-center justify-between"><span>Turnover on downs</span><span class="text-zinc-200">${breakdown.downs}</span></div>
                <div class="flex items-center justify-between"><span>End of half/game</span><span class="text-zinc-200">${breakdown.end_half_game}</span></div>
                <div class="flex items-center justify-between"><span>Missed FG</span><span class="text-zinc-200">${breakdown.missed_fg}</span></div>
            </div>
        </details>` : '';
    const infoQuality = quality || { pct: null, missing: [], missingCounts: {}, label: 'Failed', note: 'Quality not available' };
    const infoIcon = qualityInfoIcon('Failed data', infoQuality);
    const warningIcon = quality ? qualityWarningIcon('Failed data', quality) : '';
    return `<div class="stat-card glass rounded-xl p-4 text-center">
        <div class="text-xs text-zinc-500 flex items-center justify-center gap-1">
            <span>Failed</span>${warningIcon}${infoIcon}
        </div>
        <div class="text-2xl font-bold ${teamClass} mt-1">${value}</div>
        ${details}
    </div>`;
}

function formatGameDate(dateStr) {
    if (!dateStr) return '';
    const parsed = new Date(dateStr);
    if (Number.isNaN(parsed.getTime())) return dateStr;
    return new Intl.DateTimeFormat('en-US', { month: 'short', day: 'numeric' }).format(parsed);
}

function formatOpponentLabel(name, abbr) {
    const cleanName = (name || '').trim();
    const cleanAbbr = (abbr || '').trim();
    if (!cleanName && !cleanAbbr) return '';
    if (!cleanAbbr) return cleanName;
    const normName = cleanName.toUpperCase();
    const normAbbr = cleanAbbr.toUpperCase();
    if (!cleanName || normName === normAbbr || normName.includes(`(${normAbbr})`)) {
        return cleanName || cleanAbbr;
    }
    return `${cleanName} <span class="text-xs text-zinc-500">(${cleanAbbr})</span>`;
}

function parseScheduleDate(dateStr) {
    if (!dateStr) return null;
    const trimmed = dateStr.trim();
    const monthMap = {
        Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5,
        Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11
    };
    const parts = trimmed.split(' ');
    if (parts.length >= 3) {
        const month = monthMap[parts[0]];
        const day = Number(parts[1].replace(',', ''));
        const year = Number(parts[2]);
        if (Number.isInteger(month) && Number.isFinite(day) && Number.isFinite(year)) {
            return new Date(Date.UTC(year, month, day));
        }
    }
    const fallback = new Date(trimmed);
    return Number.isNaN(fallback.getTime()) ? null : fallback;
}

function scheduleTable(team, games, teamClass) {
    const outliers = computeOutlierMap(games);
    const byeWeeks = team.bye_weeks || [];
    const rows = [];
    let prevDate = null;
    let byeInserted = new Set();
    games.forEach((g, i) => {
        const currentDate = parseScheduleDate(g.date || g.game_date);
        // Insert bye week rows from NCAA schedule API data
        if (byeWeeks.length > 0) {
            // Check if a bye week falls between the previous game and this one
            // Use game index as a rough week proxy when schedule weeks aren't available
            const gameWeek = g.week || (i + 1);
            byeWeeks.forEach(bw => {
                if (!byeInserted.has(bw) && prevDate && currentDate) {
                    const gapDays = Math.round((currentDate - prevDate) / 86400000);
                    if (gapDays > 10) {
                        byeInserted.add(bw);
                        rows.push(`<tr class="schedule-row border-b border-white/5 bg-white/5">
                            <td class="py-2 px-3 text-xs text-zinc-500 text-center" colspan="5">Bye Week (Week ${bw})</td>
                        </tr>`);
                    }
                }
            });
        } else if (prevDate && currentDate) {
            // Fallback: infer from date gaps if no bye_weeks data
            const gapDays = Math.round((currentDate - prevDate) / 86400000);
            if (gapDays > 7) {
                rows.push(`<tr class="schedule-row border-b border-white/5 bg-white/5">
                    <td class="py-2 px-3 text-xs text-zinc-500 text-center" colspan="5">Bye Week</td>
                </tr>`);
            }
        }

        const w = g.points_for > g.points_against;
        const dateLabel = formatGameDate(g.date || g.game_date);
        const opponentLabel = formatOpponentLabel(g.opponent, g.opponent_abbr);
        const gameKey = g.game_number || (i + 1);
        const outlierList = outliers[gameKey] || [];
        const outlierBadge = outlierList.length ? `
            <span class="dq-tooltip dq-outlier ml-2">
                OUT
                <span class="dq-tooltip-content">
                    <div class="text-xs font-semibold text-white mb-1">Outlier flag</div>
                    <div class="text-xs text-zinc-400">${outlierList.join(', ')}</div>
                </span>
            </span>` : '';
        rows.push(`<tr class="schedule-row border-b border-white/5">
            <td class="py-2 px-3 text-xs text-zinc-400">${i + 1}</td>
            <td class="py-2 px-3 text-sm">
                ${opponentLabel}
                ${dateLabel ? `<div class="text-xs text-zinc-500">${dateLabel}</div>` : ''}
            </td>
            <td class="py-2 px-3 text-sm font-bold ${w ? 'text-green-400' : 'text-red-400'}">${w ? 'W' : 'L'} ${g.points_for}-${g.points_against}${outlierBadge}</td>
            <td class="py-2 px-3 text-xs text-zinc-400">${g.explosives} expl</td>
            <td class="py-2 px-3 text-xs text-zinc-400">${g.red_zone_tds}/${g.red_zone_trips} RZ</td>
        </tr>`);
        if (currentDate) prevDate = currentDate;
    });
    return `<div class="glass rounded-xl overflow-hidden">
        <div class="px-4 py-3 border-b border-white/5"><span class="font-semibold ${teamClass}">${team.name}</span> <span class="text-zinc-500 text-sm">Schedule</span></div>
        <table class="w-full"><tbody>${rows.join('')}</tbody></table>
    </div>`;
}

function chartContainer(id, h='300px') {
    return `<div class="chart-shell" style="height:${h}">
        <div class="chart-skeleton"></div>
        <div id="${id}" class="chart-surface" style="height:${h}"></div>
    </div>`;
}

function collapsible(title, count, content) {
    const uid = 'coll_' + Math.random().toString(36).substr(2,9);
    return `<div class="glass rounded-xl mt-4 overflow-hidden">
        <button id="${uid}_btn" aria-controls="${uid}" aria-expanded="false" aria-label="${title} collapsible section" onclick="toggleCollapsible('${uid}', this)" class="collapsible-toggle w-full px-4 py-3 flex items-center justify-between text-sm text-zinc-400 hover:text-zinc-200 transition">
            <span>${title} ‚Äî ${count} plays</span>
            <svg class="chevron w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/></svg>
        </button>
        <div id="${uid}" class="collapsible-body">${content}</div>
    </div>`;
}

function toggleCollapsible(id, btn) {
    const body = document.getElementById(id);
    if (!body) return;
    body.classList.toggle('open');
    if (btn) {
        const expanded = body.classList.contains('open');
        btn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        const chevron = btn.querySelector('.chevron');
        if (chevron) chevron.classList.toggle('open', expanded);
    }
}

function fourthDownNote() {
    if (currentTab !== '4thdown') return '';
    return `<div class="glass rounded-xl p-4 mb-4"><div class="text-sm text-zinc-400"><strong class="text-white">Note:</strong> This data includes only 4th down conversion attempts ("going for it"), not punts or field goals.</div></div>`;
}

// ===== TAB RENDERERS =====

function renderOverview() {
    const ga = DATA.teams.georgia, aa = DATA.teams.asu;
    const gf = filterGames(ga.games), af = filterGames(aa.games);
    const gs = agg(gf), as_ = agg(af);
    const gq = makeQuality(gf);
    const aq = makeQuality(af);
    const gQuality = computeTeamQuality(gf);
    const aQuality = computeTeamQuality(af);

    let html = `<div class="section-enter">`;
    html += fourthDownNote();
    html += renderQualityScoreCard(ga, aa, gQuality, aQuality);
    const splitLabels = { all: 'All Games', conf: 'Conference Games', nonconf: 'Non-Conference Games' };
    const activeSplit = FILTER_TO_SPLIT[currentFilter] || 'all';
    const splitNote = currentFilter === 'power4' || currentFilter === 'last3'
        ? '<div class="text-xs text-amber-400/70 mb-2">Showing all-games rankings (no split available for this filter)</div>' : '';
    html += `<div class="glass rounded-xl p-4 mb-6">
        <div class="text-sm text-zinc-300 font-medium mb-1">Conference Context</div>
        <div class="text-xs text-zinc-400 mb-3">${splitLabels[activeSplit] || 'All Games'} ‚Äî scoring offense/defense and third down rankings</div>
        ${splitNote}
        <div class="grid grid-cols-2 gap-4">
            <div>
                <div class="text-xs text-zinc-500 mb-2">${ga.name}</div>
                ${renderContextBadgeGroup(ga, 'team-a-badge', ['scoring_offense', 'scoring_defense', 'third_down'], 'No scoring or third down rankings available.')}
            </div>
            <div>
                <div class="text-xs text-zinc-500 mb-2">${aa.name}</div>
                ${renderContextBadgeGroup(aa, 'team-b-badge', ['scoring_offense', 'scoring_defense', 'third_down'], 'No scoring or third down rankings available.')}
            </div>
        </div>
    </div>`;
    const rankingCard = (team, label, key, teamClass) => {
        const entry = getRanking(team, key);
        const value = entry && entry.value ? entry.value : '‚Äî';
        return statCard(label, value, '', teamClass, null, buildStatBadge(team, key));
    };
    html += `<div class="glass rounded-xl p-4 mb-6">
        <div class="text-sm text-zinc-300 font-medium mb-1">Conference Rankings</div>
        <div class="text-xs text-zinc-400 mb-3">${splitLabels[activeSplit] || 'All Games'} ‚Äî team ranks within conference (CFBStats)</div>
        ${splitNote}
        <div class="grid grid-cols-2 gap-4">
            <div class="grid grid-cols-2 gap-3">
                ${rankingCard(ga, 'Scoring Margin', 'scoring_margin', 'team-a')}
                ${rankingCard(ga, 'Time of Possession', 'time_of_possession', 'team-a')}
                ${rankingCard(ga, 'Total Offense Yds/G', 'total_offense', 'team-a')}
                ${rankingCard(ga, 'Total Defense Yds/G', 'total_defense', 'team-a')}
                ${rankingCard(ga, 'Rushing Off Yds/G', 'rushing_offense', 'team-a')}
                ${rankingCard(ga, 'Rushing Def Yds/G', 'rushing_defense', 'team-a')}
                ${rankingCard(ga, 'Passing Off Yds/G', 'passing_offense', 'team-a')}
                ${rankingCard(ga, 'Passing Def Yds/G', 'passing_defense', 'team-a')}
                ${rankingCard(ga, 'Sacks Allowed', 'sacks_offense', 'team-a')}
                ${rankingCard(ga, 'Sacks (Defense)', 'sacks_defense', 'team-a')}
            </div>
            <div class="grid grid-cols-2 gap-3">
                ${rankingCard(aa, 'Scoring Margin', 'scoring_margin', 'team-b')}
                ${rankingCard(aa, 'Time of Possession', 'time_of_possession', 'team-b')}
                ${rankingCard(aa, 'Total Offense Yds/G', 'total_offense', 'team-b')}
                ${rankingCard(aa, 'Total Defense Yds/G', 'total_defense', 'team-b')}
                ${rankingCard(aa, 'Rushing Off Yds/G', 'rushing_offense', 'team-b')}
                ${rankingCard(aa, 'Rushing Def Yds/G', 'rushing_defense', 'team-b')}
                ${rankingCard(aa, 'Passing Off Yds/G', 'passing_offense', 'team-b')}
                ${rankingCard(aa, 'Passing Def Yds/G', 'passing_defense', 'team-b')}
                ${rankingCard(aa, 'Sacks Allowed', 'sacks_offense', 'team-b')}
                ${rankingCard(aa, 'Sacks (Defense)', 'sacks_defense', 'team-b')}
            </div>
        </div>
    </div>`;
    // Stat cards
    html += `<div class="grid grid-cols-2 gap-4 mb-6">
        <div class="grid grid-cols-2 gap-3">
            ${statCard('Record', gs.record, gs.ppg+' PPG', 'team-a', gq(['points_for','points_against'], 'Record'))}
            ${statCard('TO Margin', gs.tom > 0 ? '+'+gs.tom : gs.tom, gs.tof+' forced', 'team-a', gq(['turnovers_gained','turnovers_lost'], 'TO Margin'), buildStatBadge(ga, 'turnover_margin'))}
        </div>
        <div class="grid grid-cols-2 gap-3">
            ${statCard('Record', as_.record, as_.ppg+' PPG', 'team-b', aq(['points_for','points_against'], 'Record'))}
            ${statCard('TO Margin', as_.tom > 0 ? '+'+as_.tom : as_.tom, as_.tof+' forced', 'team-b', aq(['turnovers_gained','turnovers_lost'], 'TO Margin'), buildStatBadge(aa, 'turnover_margin'))}
        </div>
    </div>`;

    // Comparison bars
    html += compBar('Points Per Game', gs.ppg, as_.ppg);
    html += compBar('Opp PPG', gs.oppg, as_.oppg);
    html += compBar('Explosives/Game', gs.explpg, as_.explpg);
    html += compBar('Penalties/Game', gs.penpg, as_.penpg);
    html += compBar('RZ TD%', gs.rztdpct, as_.rztdpct, '%');

    // Points by game chart
    html += `<div class="glass rounded-xl p-4 mt-6">${chartContainer('ppgChart')}</div>`;

    // Schedule tables
    html += `<div class="grid grid-cols-2 gap-4 mt-6">
        ${scheduleTable(ga, gf, 'team-a')}
        ${scheduleTable(aa, af, 'team-b')}
    </div>`;
    html += `</div>`;
    return html;
}

function initTrendsCharts() {
    const ga = DATA.teams.georgia, aa = DATA.teams.asu;
    const gf = filterGames(ga.games), af = filterGames(aa.games);
    const teamNames = [ga.name, aa.name];
    const maxLen = Math.max(gf.length, af.length);
    const xLabels = Array.from({ length: maxLen }, (_, i) => `G${i + 1}`);

    const seriesData = (games, fn) => {
        const arr = Array(maxLen).fill(null);
        games.forEach((g, i) => { arr[i] = fn(g); });
        return arr;
    };

    const trendTooltip = (params) => {
        if (!params || !params.length) return '';
        const idx = params[0].dataIndex;
        let tip = `<div class="text-xs text-zinc-400 mb-1">G${idx + 1}</div>`;
        const shownTeams = new Set();
        params.forEach(p => {
            if (p.value === null || p.value === '-' || typeof p.value === 'undefined') return;
            tip += `${p.marker} ${p.seriesName}: ${p.value}<br/>`;
            const teamName = teamNames.find(n => p.seriesName.startsWith(n));
            if (teamName && !shownTeams.has(teamName)) {
                const games = teamName === teamNames[0] ? gf : af;
                const g = games[idx];
                if (g) {
                    const date = g.date ? ` (${g.date})` : '';
                    tip += `<span class="text-zinc-500">vs ${g.opponent}${date}</span><br/>`;
                }
                shownTeams.add(teamName);
            }
        });
        return tip;
    };

    const baseOption = {
        backgroundColor: 'transparent',
        tooltip: { trigger: 'axis', axisPointer: { type: 'line' }, formatter: trendTooltip },
        legend: { textStyle: { color: '#a1a1aa' } },
        grid: { left: 40, right: 20, top: 40, bottom: 30 },
        xAxis: { type: 'category', data: xLabels, axisLabel: { color: '#71717a' } },
        yAxis: { type: 'value', axisLabel: { color: '#71717a' }, splitLine: { lineStyle: { color: 'rgba(255,255,255,0.05)' } } },
        series: [],
    };

    const makeLine = (name, data, color, areaOpacity = 0.12) => ({
        name,
        type: 'line',
        smooth: true,
        showSymbol: false,
        connectNulls: false,
        data,
        lineStyle: { width: 2 },
        itemStyle: { color },
        areaStyle: areaOpacity ? { opacity: areaOpacity } : undefined,
        emphasis: { focus: 'series' },
    });

    const outlierMarkPoint = (data, color, limit = 1) => {
        const outliers = findOutliers(data, 1.7, limit);
        if (!outliers.length) return undefined;
        return {
            symbol: 'diamond',
            symbolSize: 12,
            label: { show: true, formatter: '!', color: '#0f0f13', fontWeight: 700 },
            data: outliers.map(o => ({
                coord: [xLabels[o.index], o.value],
                value: o.value,
                itemStyle: { color },
            })),
        };
    };

    const pointsChart = safeInitChart('trendPoints');
    if (pointsChart) safeSetOption(pointsChart, 'trendPoints', {
        ...baseOption,
        legend: { ...baseOption.legend, data: [
            `${ga.name} Scored`, `${ga.name} Allowed`,
            `${aa.name} Scored`, `${aa.name} Allowed`
        ]},
        series: [
            { ...makeLine(`${ga.name} Scored`, seriesData(gf, g => g.points_for), '#ef4444', 0.16), markPoint: outlierMarkPoint(seriesData(gf, g => g.points_for), '#ef4444') },
            { ...makeLine(`${ga.name} Allowed`, seriesData(gf, g => g.points_against), '#fca5a5', 0.08), markPoint: outlierMarkPoint(seriesData(gf, g => g.points_against), '#fca5a5') },
            { ...makeLine(`${aa.name} Scored`, seriesData(af, g => g.points_for), '#f97316', 0.16), markPoint: outlierMarkPoint(seriesData(af, g => g.points_for), '#f97316') },
            { ...makeLine(`${aa.name} Allowed`, seriesData(af, g => g.points_against), '#fdba74', 0.08), markPoint: outlierMarkPoint(seriesData(af, g => g.points_against), '#fdba74') },
        ],
    });

    const explChart = safeInitChart('trendExplosives');
    if (explChart) safeSetOption(explChart, 'trendExplosives', {
        ...baseOption,
        legend: { ...baseOption.legend, data: [`${ga.name} Explosives`, `${aa.name} Explosives`] },
        series: [
            { ...makeLine(`${ga.name} Explosives`, seriesData(gf, g => g.explosives), '#ef4444', 0.12), markPoint: outlierMarkPoint(seriesData(gf, g => g.explosives), '#ef4444') },
            { ...makeLine(`${aa.name} Explosives`, seriesData(af, g => g.explosives), '#f97316', 0.12), markPoint: outlierMarkPoint(seriesData(af, g => g.explosives), '#f97316') },
        ],
    });

    const toChart = safeInitChart('trendTurnovers');
    if (toChart) safeSetOption(toChart, 'trendTurnovers', {
        ...baseOption,
        legend: { ...baseOption.legend, data: [`${ga.name} Margin`, `${aa.name} Margin`] },
        yAxis: { ...baseOption.yAxis, splitLine: baseOption.yAxis.splitLine },
        series: [
            { ...makeLine(`${ga.name} Margin`, seriesData(gf, g => g.turnovers_gained - g.turnovers_lost), '#ef4444', 0), markPoint: outlierMarkPoint(seriesData(gf, g => g.turnovers_gained - g.turnovers_lost), '#ef4444') },
            { ...makeLine(`${aa.name} Margin`, seriesData(af, g => g.turnovers_gained - g.turnovers_lost), '#f97316', 0), markPoint: outlierMarkPoint(seriesData(af, g => g.turnovers_gained - g.turnovers_lost), '#f97316') },
        ],
    });

    const rzChart = safeInitChart('trendRedZone');
    if (rzChart) safeSetOption(rzChart, 'trendRedZone', {
        ...baseOption,
        legend: { ...baseOption.legend, data: [`${ga.name} RZ%`, `${aa.name} RZ%`] },
        yAxis: { ...baseOption.yAxis, max: 100, min: 0 },
        series: [
            { ...makeLine(`${ga.name} RZ%`, seriesData(gf, g => g.red_zone_trips ? +(((g.red_zone_tds + g.red_zone_fgs) / g.red_zone_trips) * 100).toFixed(1) : null), '#ef4444', 0.14), markPoint: outlierMarkPoint(seriesData(gf, g => g.red_zone_trips ? +(((g.red_zone_tds + g.red_zone_fgs) / g.red_zone_trips) * 100).toFixed(1) : null), '#ef4444') },
            { ...makeLine(`${aa.name} RZ%`, seriesData(af, g => g.red_zone_trips ? +(((g.red_zone_tds + g.red_zone_fgs) / g.red_zone_trips) * 100).toFixed(1) : null), '#f97316', 0.14), markPoint: outlierMarkPoint(seriesData(af, g => g.red_zone_trips ? +(((g.red_zone_tds + g.red_zone_fgs) / g.red_zone_trips) * 100).toFixed(1) : null), '#f97316') },
        ],
    });

    const penChart = safeInitChart('trendPenalties');
    if (penChart) safeSetOption(penChart, 'trendPenalties', {
        ...baseOption,
        legend: { ...baseOption.legend, data: [`${ga.name} Penalties`, `${aa.name} Penalties`] },
        series: [
            { ...makeLine(`${ga.name} Penalties`, seriesData(gf, g => g.penalties), '#ef4444', 0.1), markPoint: outlierMarkPoint(seriesData(gf, g => g.penalties), '#ef4444') },
            { ...makeLine(`${aa.name} Penalties`, seriesData(af, g => g.penalties), '#f97316', 0.1), markPoint: outlierMarkPoint(seriesData(af, g => g.penalties), '#f97316') },
        ],
    });

    const charts = [pointsChart, explChart, toChart, rzChart, penChart].filter(Boolean);
    window.addEventListener('resize', () => charts.forEach(ch => ch.resize()));
}

function initOverviewCharts() {
    const ga = DATA.teams.georgia, aa = DATA.teams.asu;
    const gf = filterGames(ga.games), af = filterGames(aa.games);
    const c = safeInitChart('ppgChart');
    if (!c) return;
    safeSetOption(c, 'ppgChart', {
        backgroundColor: 'transparent',
        tooltip: { 
            trigger: 'axis',
            formatter: (params) => {
                const i = params[0].dataIndex;
                const gGame = gf[i];
                const aGame = af[i];
                let tip = '';
                params.forEach(p => {
                    const g = p.seriesName === 'Georgia' ? gGame : aGame;
                    tip += `${p.marker} ${p.seriesName}: ${p.value}<br/>`;
                    if (g) tip += `vs ${g.opponent} ${g.date ? '(' + g.date + ')' : ''}<br/>`;
                });
                return tip;
            }
        },
        legend: { data: ['Georgia', 'Arizona State'], textStyle: { color: '#a1a1aa' } },
        xAxis: { type: 'category', data: gf.map((g,i) => 'G'+(i+1)), axisLabel: { color: '#71717a' } },
        yAxis: { type: 'value', axisLabel: { color: '#71717a' }, splitLine: { lineStyle: { color: 'rgba(255,255,255,0.05)' } } },
        series: [
            { name: 'Georgia', type: 'bar', data: gf.map(g => g.points_for), itemStyle: { color: '#ef4444' } },
            { name: 'Arizona State', type: 'bar', data: af.map(g => g.points_for), itemStyle: { color: '#f97316' } }
        ]
    });
    window.addEventListener('resize', () => c.resize());
}

function renderExplosives() {
    const ga = DATA.teams.georgia, aa = DATA.teams.asu;
    const gf = filterGames(ga.games), af = filterGames(aa.games);
    const gs = agg(gf), as_ = agg(af);
    const gq = makeQuality(gf);
    const aq = makeQuality(af);
    const computeExplosivesAllowed = (game, teamAbbr) => {
        const playTree = game.play_tree || [];
        let total = 0;
        let rush = 0;
        let pass = 0;
        let plays = 0;
        let drives = 0;
        playTree.forEach(q => {
            (q.drives || []).forEach(d => {
                const dPlays = d.plays || [];
                const defDrive = d.offense && d.offense !== teamAbbr;
                let driveHasPlay = false;
                dPlays.forEach(p => {
                    if (!p || !p.offense || p.offense === teamAbbr || p.is_no_play) return;
                    plays += 1;
                    driveHasPlay = true;
                    const yards = p.yards;
                    if (yards === undefined || yards === null) return;
                    const desc = (p.description || '').toUpperCase();
                    const isPass = desc.includes('PASS') || desc.includes('COMPLETE') || desc.includes('CAUGHT');
                    const threshold = isPass ? 20 : 15;
                    if (yards >= threshold) {
                        total += 1;
                        if (isPass) {
                            pass += 1;
                        } else {
                            rush += 1;
                        }
                    }
                });
                if (defDrive && driveHasPlay) drives += 1;
            });
        });
        return { total, rush, pass, plays, drives };
    };
    const gExplRush = sumField(gf, 'explosive_rushes');
    const gExplPass = sumField(gf, 'explosive_passes');
    const aExplRush = sumField(af, 'explosive_rushes');
    const aExplPass = sumField(af, 'explosive_passes');
    const gExplRushPg = (gExplRush / (gf.length || 1)).toFixed(1);
    const gExplPassPg = (gExplPass / (gf.length || 1)).toFixed(1);
    const aExplRushPg = (aExplRush / (af.length || 1)).toFixed(1);
    const aExplPassPg = (aExplPass / (af.length || 1)).toFixed(1);
    const gLeaders = buildExplosiveLeaders(gf);
    const aLeaders = buildExplosiveLeaders(af);

    const gDefStats = gf.map(g => computeExplosivesAllowed(g, ga.abbr));
    const aDefStats = af.map(g => computeExplosivesAllowed(g, aa.abbr));
    const sumDef = (arr, key) => arr.reduce((s, d) => s + (d[key] || 0), 0);
    const gDefTotal = sumDef(gDefStats, 'total');
    const aDefTotal = sumDef(aDefStats, 'total');
    const gDefRush = sumDef(gDefStats, 'rush');
    const aDefRush = sumDef(aDefStats, 'rush');
    const gDefPass = sumDef(gDefStats, 'pass');
    const aDefPass = sumDef(aDefStats, 'pass');
    const gDefPlays = sumDef(gDefStats, 'plays');
    const aDefPlays = sumDef(aDefStats, 'plays');
    const gDefDrives = sumDef(gDefStats, 'drives');
    const aDefDrives = sumDef(aDefStats, 'drives');
    const gDefTotalPg = (gDefTotal / (gf.length || 1)).toFixed(1);
    const aDefTotalPg = (aDefTotal / (af.length || 1)).toFixed(1);
    const gDefRushPg = (gDefRush / (gf.length || 1)).toFixed(1);
    const aDefRushPg = (aDefRush / (af.length || 1)).toFixed(1);
    const gDefPassPg = (gDefPass / (gf.length || 1)).toFixed(1);
    const aDefPassPg = (aDefPass / (af.length || 1)).toFixed(1);
    const gDefRate = gDefPlays ? ((gDefTotal / gDefPlays) * 100).toFixed(1) : '0.0';
    const aDefRate = aDefPlays ? ((aDefTotal / aDefPlays) * 100).toFixed(1) : '0.0';
    const gDefPerDrive = gDefDrives ? (gDefTotal / gDefDrives).toFixed(2) : '0.00';
    const aDefPerDrive = aDefDrives ? (aDefTotal / aDefDrives).toFixed(2) : '0.00';

    let html = `<div class="section-enter">`;
    html += fourthDownNote();
    html += `<div class="glass rounded-xl p-4 mb-4">
        <div class="text-sm text-zinc-300 font-medium">Definition</div>
        <div class="text-xs text-zinc-400 mt-1">Explosive plays: rushes of 15+ yards or passes of 20+ yards</div>
    </div>`;
    html += `<div class="glass rounded-xl p-4 mb-4">
        <div class="text-sm text-zinc-300 font-medium mb-3">Conference Context</div>
        <div class="grid grid-cols-2 gap-4">
            <div>
                <div class="text-xs text-zinc-500 mb-2">${ga.name}</div>
                ${renderContextBadges(ga, 'team-a-badge', 'explosives', 'No explosive plays ranking available.')}
            </div>
            <div>
                <div class="text-xs text-zinc-500 mb-2">${aa.name}</div>
                ${renderContextBadges(aa, 'team-b-badge', 'explosives', 'No explosive plays ranking available.')}
            </div>
        </div>
    </div>`;
    html += `<div class="grid grid-cols-2 gap-4 mb-6">
        ${statCard('Total Explosives', gs.expl, gs.explpg+'/game', 'team-a', gq(['explosives'], 'Total Explosives'))}
        ${statCard('Total Explosives', as_.expl, as_.explpg+'/game', 'team-b', aq(['explosives'], 'Total Explosives'))}
    </div>`;
    html += `<div class="grid grid-cols-2 gap-4 mb-6">
        <div class="grid grid-cols-2 gap-3">
            ${statCard('Explosive Rushes', gExplRush, gExplRushPg+'/game', 'team-a', gq(['explosive_rushes'], 'Explosive Rushes'))}
            ${statCard('Explosive Passes', gExplPass, gExplPassPg+'/game', 'team-a', gq(['explosive_passes'], 'Explosive Passes'))}
        </div>
        <div class="grid grid-cols-2 gap-3">
            ${statCard('Explosive Rushes', aExplRush, aExplRushPg+'/game', 'team-b', aq(['explosive_rushes'], 'Explosive Rushes'))}
            ${statCard('Explosive Passes', aExplPass, aExplPassPg+'/game', 'team-b', aq(['explosive_passes'], 'Explosive Passes'))}
        </div>
    </div>`;
    html += `<div class="grid grid-cols-2 gap-4 mb-6">
        ${renderExplosiveLeaders('Georgia Explosive Leaders', gLeaders, 'team-a')}
        ${renderExplosiveLeaders('Arizona State Explosive Leaders', aLeaders, 'team-b')}
    </div>`;
    html += `<div class="glass rounded-xl p-4 mb-4">
        <div class="text-sm text-zinc-300 font-medium">Defensive Explosives Allowed</div>
        <div class="text-xs text-zinc-400 mt-1">Explosives conceded by the defense (derived from opponent plays)</div>
    </div>`;
    html += `<div class="grid grid-cols-2 gap-4 mb-4">
        ${statCard('Explosives Allowed', gDefTotal, gDefTotalPg+'/game', 'team-a', gq(['play_tree'], 'Explosives Allowed', 'Derived from opponent plays.'))}
        ${statCard('Explosives Allowed', aDefTotal, aDefTotalPg+'/game', 'team-b', aq(['play_tree'], 'Explosives Allowed', 'Derived from opponent plays.'))}
    </div>`;
    html += `<div class="grid grid-cols-2 gap-4 mb-4">
        <div class="grid grid-cols-2 gap-3">
            ${statCard('Explosive Rushes Allowed', gDefRush, gDefRushPg+'/game', 'team-a', gq(['play_tree'], 'Explosive Rushes Allowed', 'Derived from opponent plays.'))}
            ${statCard('Explosive Passes Allowed', gDefPass, gDefPassPg+'/game', 'team-a', gq(['play_tree'], 'Explosive Passes Allowed', 'Derived from opponent plays.'))}
        </div>
        <div class="grid grid-cols-2 gap-3">
            ${statCard('Explosive Rushes Allowed', aDefRush, aDefRushPg+'/game', 'team-b', aq(['play_tree'], 'Explosive Rushes Allowed', 'Derived from opponent plays.'))}
            ${statCard('Explosive Passes Allowed', aDefPass, aDefPassPg+'/game', 'team-b', aq(['play_tree'], 'Explosive Passes Allowed', 'Derived from opponent plays.'))}
        </div>
    </div>`;
    html += `<div class="grid grid-cols-2 gap-4 mb-6">
        <div class="grid grid-cols-2 gap-3">
            ${statCard('Explosive Rate Allowed', gDefRate+'%', `${gDefTotal}/${gDefPlays || 0} plays`, 'team-a', gq(['play_tree'], 'Explosive Rate Allowed', 'Explosive plays divided by opponent plays.'))}
            ${statCard('Explosives/Drive Allowed', gDefPerDrive, `${gDefTotal}/${gDefDrives || 0} drives`, 'team-a', gq(['play_tree'], 'Explosives/Drive Allowed', 'Explosive plays divided by opponent drives.'))}
        </div>
        <div class="grid grid-cols-2 gap-3">
            ${statCard('Explosive Rate Allowed', aDefRate+'%', `${aDefTotal}/${aDefPlays || 0} plays`, 'team-b', aq(['play_tree'], 'Explosive Rate Allowed', 'Explosive plays divided by opponent plays.'))}
            ${statCard('Explosives/Drive Allowed', aDefPerDrive, `${aDefTotal}/${aDefDrives || 0} drives`, 'team-b', aq(['play_tree'], 'Explosives/Drive Allowed', 'Explosive plays divided by opponent drives.'))}
        </div>
    </div>`;
    html += compBar('Explosives Allowed/Game', parseFloat(gDefTotalPg), parseFloat(aDefTotalPg));
    html += compBar('Explosives/Game', gs.explpg, as_.explpg);
    html += `<div class="glass rounded-xl p-4 mt-4">
        <div class="text-sm text-zinc-300 font-medium mb-2">Explosive Plays Trend (Rush/Pass)</div>
        ${chartContainer('explChart')}
    </div>`;
    html += `<div class="glass rounded-xl p-4 mt-4">
        <div class="text-sm text-zinc-300 font-medium mb-2">Explosives Gained vs Allowed</div>
        ${chartContainer('explCompareChart')}
    </div>`;

    // Helper to render explosive plays table with grouping
    const renderExplTable = (games, teamClass) => {
        const allExpl = games.flatMap((g,i) => (g.explosive_details||[]).map(e => ({...e, opponent: g.opponent, game: i+1})));
        if (!allExpl.length) return `<div class="text-zinc-500 text-xs p-4">No explosive plays found.</div>`;
        
        const rushPlays = allExpl.filter(e => e.type === 'rush');
        const passPlays = allExpl.filter(e => e.type === 'pass');
        
        let tbl = `<div class="space-y-3">`;
        if (rushPlays.length) {
            tbl += `<div><div class="text-xs font-semibold text-zinc-400 mb-2 px-2">Rush (${rushPlays.length} plays)</div>
            <table class="w-full text-xs"><thead class="sticky top-0 bg-zinc-900"><tr>
                <th class="py-2 px-2 text-left text-zinc-500">G#</th>
                <th class="py-2 px-2 text-left text-zinc-500">Opp</th>
                <th class="py-2 px-2 text-left text-zinc-500">Type</th>
                <th class="py-2 px-2 text-right text-zinc-500">Yds</th>
                <th class="py-2 px-2 text-left text-zinc-500">Description</th>
            </tr></thead><tbody>${rushPlays.map(e => `<tr class="border-b border-white/5 table-row">
                <td class="py-1 px-2 text-zinc-400">G${e.game}</td>
                <td class="py-1 px-2">${e.opponent||''}</td>
                <td class="py-1 px-2 text-green-400">Run</td>
                <td class="py-1 px-2 text-right font-bold">${e.yards||''}</td>
                <td class="py-1 px-2 text-zinc-400">${(e.description||'').substring(0,90)}</td>
            </tr>`).join('')}</tbody></table></div>`;
        }
        if (passPlays.length) {
            tbl += `<div><div class="text-xs font-semibold text-zinc-400 mb-2 px-2">Pass (${passPlays.length} plays)</div>
            <table class="w-full text-xs"><thead class="sticky top-0 bg-zinc-900"><tr>
                <th class="py-2 px-2 text-left text-zinc-500">G#</th>
                <th class="py-2 px-2 text-left text-zinc-500">Opp</th>
                <th class="py-2 px-2 text-left text-zinc-500">Type</th>
                <th class="py-2 px-2 text-right text-zinc-500">Yds</th>
                <th class="py-2 px-2 text-left text-zinc-500">Description</th>
            </tr></thead><tbody>${passPlays.map(e => `<tr class="border-b border-white/5 table-row">
                <td class="py-1 px-2 text-zinc-400">G${e.game}</td>
                <td class="py-1 px-2">${e.opponent||''}</td>
                <td class="py-1 px-2 text-blue-400">Pass</td>
                <td class="py-1 px-2 text-right font-bold">${e.yards||''}</td>
                <td class="py-1 px-2 text-zinc-400">${(e.description||'').substring(0,90)}</td>
            </tr>`).join('')}</tbody></table></div>`;
        }
        tbl += `</div>`;
        return tbl;
    };

    html += `<div class="grid grid-cols-2 gap-4 mt-4">
        ${collapsible('Georgia Explosive Plays', gf.reduce((sum,g) => sum + (g.explosive_details||[]).length, 0), renderExplTable(gf, 'team-a'))}
        ${collapsible('Arizona State Explosive Plays', af.reduce((sum,g) => sum + (g.explosive_details||[]).length, 0), renderExplTable(af, 'team-b'))}
    </div>`;
    html += `<div class="glass rounded-xl p-4 mt-6">
        <div class="text-sm text-zinc-300 font-medium mb-2">Season Trend</div>
        ${chartContainer('trendExplosives', '280px')}
    </div>`;
    html += `</div>`;
    return html;
}

function initExplosivesCharts() {
    const ga = DATA.teams.georgia, aa = DATA.teams.asu;
    const gf = filterGames(ga.games), af = filterGames(aa.games);
    const computeExplosivesAllowed = (game, teamAbbr) => {
        const playTree = game.play_tree || [];
        let total = 0;
        playTree.forEach(q => {
            (q.drives || []).forEach(d => {
                (d.plays || []).forEach(p => {
                    if (!p || !p.offense || p.offense === teamAbbr || p.is_no_play) return;
                    const yards = p.yards;
                    if (yards === undefined || yards === null) return;
                    const desc = (p.description || '').toUpperCase();
                    const isPass = desc.includes('PASS') || desc.includes('COMPLETE') || desc.includes('CAUGHT');
                    const threshold = isPass ? 20 : 15;
                    if (yards >= threshold) total += 1;
                });
            });
        });
        return total;
    };
    const gDefAllowed = gf.map(g => computeExplosivesAllowed(g, ga.abbr));
    const aDefAllowed = af.map(g => computeExplosivesAllowed(g, aa.abbr));
    const c = safeInitChart('explChart');
    if (c) safeSetOption(c, 'explChart', {
        backgroundColor: 'transparent',
        tooltip: { 
            trigger: 'axis',
            formatter: (params) => {
                const i = params[0].dataIndex;
                const gGame = gf[i];
                const aGame = af[i];
                let tip = '';
                params.forEach(p => {
                    const g = p.seriesName.startsWith(ga.name) ? gGame : aGame;
                    tip += `${p.marker} ${p.seriesName}: ${p.value}<br/>`;
                    if (g) tip += `vs ${g.opponent} ${g.date ? '(' + g.date + ')' : ''}<br/>`;
                });
                return tip;
            }
        },
        legend: { data: ['Georgia Rush', 'Georgia Pass', 'Arizona State Rush', 'Arizona State Pass'], textStyle: { color: '#a1a1aa' } },
        xAxis: { type: 'category', data: gf.map((g,i) => 'G'+(i+1)), axisLabel: { color: '#71717a' } },
        yAxis: { type: 'value', axisLabel: { color: '#71717a' }, splitLine: { lineStyle: { color: 'rgba(255,255,255,0.05)' } } },
        series: [
            { name: 'Georgia Rush', type: 'line', stack: 'Georgia', data: gf.map(g => g.explosive_rushes), itemStyle: { color: '#22c55e' }, lineStyle: { color: '#22c55e' }, areaStyle: { opacity: 0.35 }, smooth: true },
            { name: 'Georgia Pass', type: 'line', stack: 'Georgia', data: gf.map(g => g.explosive_passes), itemStyle: { color: '#3b82f6' }, lineStyle: { color: '#3b82f6' }, areaStyle: { opacity: 0.35 }, smooth: true },
            { name: 'Arizona State Rush', type: 'line', stack: 'Arizona State', data: af.map(g => g.explosive_rushes), itemStyle: { color: '#f59e0b' }, lineStyle: { color: '#f59e0b', type: 'dashed' }, areaStyle: { opacity: 0.25 }, smooth: true },
            { name: 'Arizona State Pass', type: 'line', stack: 'Arizona State', data: af.map(g => g.explosive_passes), itemStyle: { color: '#f97316' }, lineStyle: { color: '#f97316', type: 'dashed' }, areaStyle: { opacity: 0.25 }, smooth: true }
        ]
    });
    const compare = safeInitChart('explCompareChart');
    if (compare) {
        safeSetOption(compare, 'explCompareChart', {
            backgroundColor: 'transparent',
            tooltip: { 
                trigger: 'axis',
                formatter: (params) => {
                    const i = params[0].dataIndex;
                    const gGame = gf[i];
                    const aGame = af[i];
                    let tip = '';
                    params.forEach(p => {
                        const g = p.seriesName.startsWith(ga.name) ? gGame : aGame;
                        tip += `${p.marker} ${p.seriesName}: ${p.value}<br/>`;
                        if (g) tip += `vs ${g.opponent} ${g.date ? '(' + g.date + ')' : ''}<br/>`;
                    });
                    return tip;
                }
            },
            legend: { data: [`${ga.name} Gained`, `${ga.name} Allowed`, `${aa.name} Gained`, `${aa.name} Allowed`], textStyle: { color: '#a1a1aa' } },
            xAxis: { type: 'category', data: gf.map((g,i) => 'G'+(i+1)), axisLabel: { color: '#71717a' } },
            yAxis: { type: 'value', axisLabel: { color: '#71717a' }, splitLine: { lineStyle: { color: 'rgba(255,255,255,0.05)' } } },
            series: [
                { name: `${ga.name} Gained`, type: 'line', data: gf.map(g => g.explosives), itemStyle: { color: '#ef4444' }, lineStyle: { color: '#ef4444' }, smooth: true },
                { name: `${ga.name} Allowed`, type: 'line', data: gDefAllowed, itemStyle: { color: '#fca5a5' }, lineStyle: { color: '#fca5a5', type: 'dashed' }, smooth: true },
                { name: `${aa.name} Gained`, type: 'line', data: af.map(g => g.explosives), itemStyle: { color: '#f97316' }, lineStyle: { color: '#f97316' }, smooth: true },
                { name: `${aa.name} Allowed`, type: 'line', data: aDefAllowed, itemStyle: { color: '#fdba74' }, lineStyle: { color: '#fdba74', type: 'dashed' }, smooth: true }
            ]
        });
    }
    window.addEventListener('resize', () => {
        if (c) c.resize();
        if (compare) compare.resize();
    });
    initTrendsCharts();
}

function renderRedzone() {
    const ga = DATA.teams.georgia, aa = DATA.teams.asu;
    const gf = filterGames(ga.games), af = filterGames(aa.games);
    const gs = agg(gf), as_ = agg(af);
    const gq = makeQuality(gf);
    const aq = makeQuality(af);

    const renderZoneSection = (zoneName, zoneDesc, gStats, aStats, zoneKey, games_g, games_a) => {
        const zoneFields = [`${zoneKey}_trips`, `${zoneKey}_tds`, `${zoneKey}_fgs`, `${zoneKey}_failed`, 'red_zone_plays'];
        const zoneClass = zoneKey === 'green_zone' ? 'zone-green' : (zoneKey === 'red_zone' ? 'zone-red' : 'zone-tight');
        const zoneTitleClass = zoneKey === 'green_zone' ? 'zone-title-green' : (zoneKey === 'red_zone' ? 'zone-title-red' : 'zone-title-tight');
        const gTrips = gStats[`${zoneKey}_trips`] || 0;
        const gTds = gStats[`${zoneKey}_tds`] || 0;
        const gFgs = gStats[`${zoneKey}_fgs`] || 0;
        const gFailedBreakdown = computeFailedBreakdown(games_g, zoneKey);
        const gFailed = Object.values(gFailedBreakdown).reduce((s, v) => s + v, 0);
        const gTdPct = gTrips > 0 ? ((gTds / gTrips) * 100).toFixed(1) : '0.0';
        const gScorePct = gTrips > 0 ? (((gTds + gFgs) / gTrips) * 100).toFixed(1) : '0.0';

        const aTrips = aStats[`${zoneKey}_trips`] || 0;
        const aTds = aStats[`${zoneKey}_tds`] || 0;
        const aFgs = aStats[`${zoneKey}_fgs`] || 0;
        const aFailedBreakdown = computeFailedBreakdown(games_a, zoneKey);
        const aFailed = Object.values(aFailedBreakdown).reduce((s, v) => s + v, 0);
        const aTdPct = aTrips > 0 ? ((aTds / aTrips) * 100).toFixed(1) : '0.0';
        const aScorePct = aTrips > 0 ? (((aTds + aFgs) / aTrips) * 100).toFixed(1) : '0.0';

        let html = `<div class="mb-6 zone-section ${zoneClass}">`;
        html += `<h3 class="text-lg font-bold text-white mb-3 zone-title ${zoneTitleClass}">${zoneName} <span class="text-zinc-500 text-sm font-normal">${zoneDesc}</span></h3>`;
        html += `<div class="grid grid-cols-2 gap-4 mb-4">
            <div class="grid grid-cols-4 gap-3">
                ${statCard('Trips', gTrips, '', 'team-a', gq(zoneFields, `${zoneName} Trips`))}
                ${statCard('TDs', gTds, gTdPct+'%', 'team-a', gq(zoneFields, `${zoneName} TDs`))}
                ${statCard('FGs', gFgs, '', 'team-a', gq(zoneFields, `${zoneName} FGs`))}
                ${failedStatCard(gFailed, 'team-a', gFailedBreakdown, gq(zoneFields, `${zoneName} Failed`))}
            </div>
            <div class="grid grid-cols-4 gap-3">
                ${statCard('Trips', aTrips, '', 'team-b', aq(zoneFields, `${zoneName} Trips`))}
                ${statCard('TDs', aTds, aTdPct+'%', 'team-b', aq(zoneFields, `${zoneName} TDs`))}
                ${statCard('FGs', aFgs, '', 'team-b', aq(zoneFields, `${zoneName} FGs`))}
                ${failedStatCard(aFailed, 'team-b', aFailedBreakdown, aq(zoneFields, `${zoneName} Failed`))}
            </div>
        </div>`;
        html += compBar('TD Rate', parseFloat(gTdPct), parseFloat(aTdPct), '%');
        html += compBar('Score Rate', parseFloat(gScorePct), parseFloat(aScorePct), '%');

        // Collapsible play table
        const tableId = `${zoneKey}Table`;
        html += `<details class="mt-4 glass rounded-xl">
            <summary class="cursor-pointer p-3 text-sm font-medium text-white hover:bg-white/5">
                Show ${zoneName} Play Details
            </summary>
            <div class="p-4 pt-0">
                <div class="grid grid-cols-2 gap-4">`;

        const renderZonePlayTable = (games, teamName) => {
            const zonePlays = games.flatMap(g => {
                const plays = (g.red_zone_plays || []).filter(p => {
                    if (zoneKey === 'green_zone') return p.yards_to_goal <= 30;
                    if (zoneKey === 'red_zone') return p.yards_to_goal <= 20;
                    if (zoneKey === 'tight_red_zone') return p.yards_to_goal <= 10;
                    return false;
                });
                return plays.map(p => ({...p, game: g.game_number, opponent: g.opponent}));
            });

            if (!zonePlays.length) return `<div class="text-zinc-500 text-xs p-4">No plays in ${zoneName.toLowerCase()}</div>`;

            return `<table class="w-full text-xs"><thead class="sticky top-0 bg-zinc-900"><tr>
                <th class="py-2 px-2 text-left text-zinc-500">G#</th>
                <th class="py-2 px-2 text-left text-zinc-500">Opp</th>
                <th class="py-2 px-2 text-left text-zinc-500">Q</th>
                <th class="py-2 px-2 text-left text-zinc-500">Clock</th>
                <th class="py-2 px-2 text-left text-zinc-500">Down</th>
                <th class="py-2 px-2 text-left text-zinc-500">YTG</th>
                <th class="py-2 px-2 text-left text-zinc-500">Type</th>
                <th class="py-2 px-2 text-left text-zinc-500">Yds</th>
                <th class="py-2 px-2 text-left text-zinc-500">Score</th>
                <th class="py-2 px-2 text-left text-zinc-500">Description</th>
            </tr></thead><tbody>${zonePlays.map(p => `<tr class="border-t border-white/5 hover:bg-white/5">
                <td class="py-2 px-2">${p.game}</td>
                <td class="py-2 px-2">${p.opponent}</td>
                <td class="py-2 px-2">${p.quarter}</td>
                <td class="py-2 px-2">${p.clock}</td>
                <td class="py-2 px-2">${p.down_distance}</td>
                <td class="py-2 px-2">${p.yards_to_goal}</td>
                <td class="py-2 px-2">${p.play_type}</td>
                <td class="py-2 px-2">${p.yards}</td>
                <td class="py-2 px-2">${p.scoring ? '‚úÖ' : ''}</td>
                <td class="py-2 px-2 text-zinc-400">${p.description}</td>
            </tr>`).join('')}</tbody></table>`;
        };

        html += `<div><h4 class="text-sm font-medium text-white mb-2">${ga.name}</h4>${renderZonePlayTable(games_g, ga.name)}</div>`;
        html += `<div><h4 class="text-sm font-medium text-white mb-2">${aa.name}</h4>${renderZonePlayTable(games_a, aa.name)}</div>`;
        html += `</div></div></details>`;
        html += `</div>`;
        return html;
    };

    let html = `<div class="section-enter">`;
    html += fourthDownNote();
    html += `<div class="glass rounded-xl p-4 mb-4">
        <div class="text-sm font-medium text-white mb-3">Conference Context</div>
        <div class="grid grid-cols-2 gap-4">
            <div>
                <div class="text-xs text-zinc-500 mb-2">${ga.name}</div>
                ${renderContextBadges(ga, 'team-a-badge', 'red_zone', 'No red zone ranking available.')}
            </div>
            <div>
                <div class="text-xs text-zinc-500 mb-2">${aa.name}</div>
                ${renderContextBadges(aa, 'team-b-badge', 'red_zone', 'No red zone ranking available.')}
            </div>
        </div>
    </div>`;
    html += renderZoneSection('Green Zone', '(30 yards & in)', gs, as_, 'green_zone', gf, af);
    html += `<div class="border-t-2 border-zinc-700 my-6"></div>`;
    html += renderZoneSection('Red Zone', '(20 yards & in)', gs, as_, 'red_zone', gf, af);
    html += `<div class="border-t-2 border-zinc-700 my-6"></div>`;
    html += renderZoneSection('Tight Red Zone', '(10 yards & in)', gs, as_, 'tight_red_zone', gf, af);
    html += `<div class="glass rounded-xl p-4 mt-6">
        <div class="text-sm text-zinc-300 font-medium mb-2">Season Trend</div>
        ${chartContainer('trendRedZone', '280px')}
    </div>`;
    html += `</div>`;
    return html;
}

function initRedzoneCharts() {
    const gs = agg(filterGames(DATA.teams.georgia.games));
    const as_ = agg(filterGames(DATA.teams.asu.games));
    const noScore = (s) => Math.max(0, s.rzt - s.rztd - s.rzfg);
    [['rzChartA', gs, '#ef4444', 'Georgia'], ['rzChartB', as_, '#f97316', 'Arizona State']].forEach(([id, s, col, name]) => {
        const c = safeInitChart(id);
        if (!c) return;
        safeSetOption(c, id, {
            backgroundColor: 'transparent',
            title: { text: name, left: 'center', textStyle: { color: '#a1a1aa', fontSize: 13 } },
            tooltip: { trigger: 'item' },
            series: [{ type: 'pie', radius: ['40%','70%'], data: [
                { value: s.rztd, name: 'TD', itemStyle: { color: '#22c55e' } },
                { value: s.rzfg, name: 'FG', itemStyle: { color: '#eab308' } },
                { value: noScore(s), name: 'No Score', itemStyle: { color: '#71717a' } },
            ], label: { color: '#a1a1aa', fontSize: 11 } }]
        });
        window.addEventListener('resize', () => c.resize());
    });
    initTrendsCharts();
}

function renderTurnovers() {
    const ga = DATA.teams.georgia, aa = DATA.teams.asu;
    const gf = filterGames(ga.games), af = filterGames(aa.games);
    const gs = agg(gf), as_ = agg(af);
    const gq = makeQuality(gf);
    const aq = makeQuality(af);
    const gIntLost = sumField(gf, 'interceptions_lost');
    const gIntGained = sumField(gf, 'interceptions_gained');
    const gFumLost = sumField(gf, 'fumbles_lost');
    const gFumGained = sumField(gf, 'fumbles_gained');
    const aIntLost = sumField(af, 'interceptions_lost');
    const aIntGained = sumField(af, 'interceptions_gained');
    const aFumLost = sumField(af, 'fumbles_lost');
    const aFumGained = sumField(af, 'fumbles_gained');
    let html = `<div class="section-enter">`;
    html += fourthDownNote();
    html += `<div class="grid grid-cols-2 gap-4 mb-6">
        ${statCard('TO Margin', gs.tom>0?'+'+gs.tom:gs.tom, gs.tof+' forced / '+gs.tol+' lost', 'team-a', gq(['turnovers_gained','turnovers_lost'], 'TO Margin'), buildStatBadge(ga, 'turnover_margin'))}
        ${statCard('TO Margin', as_.tom>0?'+'+as_.tom:as_.tom, as_.tof+' forced / '+as_.tol+' lost', 'team-b', aq(['turnovers_gained','turnovers_lost'], 'TO Margin'), buildStatBadge(aa, 'turnover_margin'))}
    </div>`;
    html += `<div class="grid grid-cols-2 gap-4 mb-6">
        <div class="grid grid-cols-4 gap-3">
            ${statCard('INT Gained', gIntGained, '', 'team-a', gq(['interceptions_gained'], 'INT Gained'))}
            ${statCard('INT Lost', gIntLost, '', 'team-a', gq(['interceptions_lost'], 'INT Lost'))}
            ${statCard('Fum Gained', gFumGained, '', 'team-a', gq(['fumbles_gained'], 'Fum Gained'))}
            ${statCard('Fum Lost', gFumLost, '', 'team-a', gq(['fumbles_lost'], 'Fum Lost'))}
        </div>
        <div class="grid grid-cols-4 gap-3">
            ${statCard('INT Gained', aIntGained, '', 'team-b', aq(['interceptions_gained'], 'INT Gained'))}
            ${statCard('INT Lost', aIntLost, '', 'team-b', aq(['interceptions_lost'], 'INT Lost'))}
            ${statCard('Fum Gained', aFumGained, '', 'team-b', aq(['fumbles_gained'], 'Fum Gained'))}
            ${statCard('Fum Lost', aFumLost, '', 'team-b', aq(['fumbles_lost'], 'Fum Lost'))}
        </div>
    </div>`;
    html += compBar('Turnovers Forced', gs.tof, as_.tof);
    html += compBar('Turnovers Lost', gs.tol, as_.tol);
    html += `<div class="glass rounded-xl p-4 mt-4">${chartContainer('toChart')}</div>`;
    html += `<div class="grid grid-cols-2 gap-4 mt-4">
        <div class="glass rounded-xl p-4">${chartContainer('toSplitGained', '260px')}</div>
        <div class="glass rounded-xl p-4">${chartContainer('toSplitLost', '260px')}</div>
    </div>`;

    const renderPlaymakers = (games, teamAbbr, teamClass) => {
        const counts = {};
        games.forEach(g => {
            const typeLookup = buildTurnoverTypeLookup(g);
            (g.play_tree || []).forEach(q => {
                q.drives.forEach(d => {
                    d.plays.filter(p => p.is_turnover).forEach(p => {
                        if (!p.offense || p.offense === teamAbbr) return;
                        const name = extractTurnoverPlaymaker(p.description || '');
                        if (!name) return;
                        const type = resolveTurnoverType(p, typeLookup);
                        if (!counts[name]) counts[name] = {int: 0, fum: 0, other: 0, total: 0};
                        if (type === 'INT') counts[name].int += 1;
                        else if (type === 'FUM') counts[name].fum += 1;
                        else counts[name].other += 1;
                        counts[name].total += 1;
                    });
                });
            });
        });
        const top = Object.entries(counts).sort((a,b) => b[1].total - a[1].total).slice(0,5);
        if (!top.length) return `<div class="text-zinc-500 text-xs p-4">No turnover playmakers found.</div>`;
        const formatBreakdown = row => {
            const parts = [];
            if (row.int) parts.push(`${row.int} INT${row.int > 1 ? 's' : ''}`);
            if (row.fum) parts.push(`${row.fum} fumble ${row.fum === 1 ? 'recovery' : 'recoveries'}`);
            if (row.other) parts.push(`${row.other} TO`);
            return parts.join(', ') || '0';
        };
        return `<div class="space-y-2">
            ${top.map((t,i) => `<div class="flex items-center justify-between text-sm">
                <span class="${teamClass}">${i+1}. ${t[0]}</span>
                <span class="text-zinc-500">${formatBreakdown(t[1])}</span>
            </div>`).join('')}
        </div>`;
    };

    html += `<div class="grid grid-cols-2 gap-4 mt-4">
        <div class="glass rounded-xl p-4">
            <div class="text-sm font-medium text-white mb-3">${ga.name} Top Playmakers</div>
            ${renderPlaymakers(gf, ga.abbr, 'team-a')}
        </div>
        <div class="glass rounded-xl p-4">
            <div class="text-sm font-medium text-white mb-3">${aa.name} Top Playmakers</div>
            ${renderPlaymakers(af, aa.abbr, 'team-b')}
        </div>
    </div>`;

    // Turnover play details
    const renderTurnoverTable = (games, teamClass) => {
        const toPlays = games.flatMap((g,idx) => {
            return (g.play_tree||[]).flatMap(q => 
                q.drives.flatMap(d => 
                    d.plays.filter(p => p.is_turnover)
                        .map(p => ({...p, game: g.game_number, opponent: g.opponent}))
                )
            );
        });
        if (!toPlays.length) return `<div class="text-zinc-500 text-xs p-4">No turnover plays found.</div>`;
        return `<table class="w-full text-xs"><thead class="sticky top-0 bg-zinc-900"><tr>
            <th class="py-2 px-2 text-left text-zinc-500">G#</th>
            <th class="py-2 px-2 text-left text-zinc-500">Opponent</th>
            <th class="py-2 px-2 text-left text-zinc-500">Quarter</th>
            <th class="py-2 px-2 text-left text-zinc-500">Clock</th>
            <th class="py-2 px-2 text-left text-zinc-500">Down/Dist</th>
            <th class="py-2 px-2 text-left text-zinc-500">Spot</th>
            <th class="py-2 px-2 text-left text-zinc-500">Team</th>
            <th class="py-2 px-2 text-left text-zinc-500">Type</th>
            <th class="py-2 px-2 text-left text-zinc-500">Playmaker</th>
            <th class="py-2 px-2 text-left text-zinc-500">Description</th>
        </tr></thead><tbody>${toPlays.map(p => `<tr class="border-b border-white/5 table-row">
            <td class="py-1 px-2 text-zinc-400">G${p.game}</td>
            <td class="py-1 px-2">${p.opponent||''}</td>
            <td class="py-1 px-2">${p.quarter}</td>
            <td class="py-1 px-2 text-zinc-400">${p.clock||''}</td>
            <td class="py-1 px-2 text-zinc-400">${p.down_distance||''}</td>
            <td class="py-1 px-2 text-zinc-400">${p.spot||''}</td>
            <td class="py-1 px-2 ${teamClass}">${p.offense||''}</td>
            <td class="py-1 px-2">
                ${(() => {
                    const type = getTurnoverType(p.description || '');
                    if (!type) return `<span class="text-zinc-500">‚Äî</span>`;
                    const cls = type === 'INT' ? 'bg-sky-500/20 text-sky-300 border-sky-500/40' : 'bg-emerald-500/20 text-emerald-300 border-emerald-500/40';
                    return `<span class="px-2 py-0.5 rounded-full border text-[10px] font-semibold ${cls}">${type}</span>`;
                })()}
            </td>
            <td class="py-1 px-2 text-zinc-300">${extractTurnoverPlaymaker(p.description || '') || '‚Äî'}</td>
            <td class="py-1 px-2 text-zinc-300">${(p.description||'').substring(0,120)}</td>
        </tr>`).join('')}</tbody></table>`;
    };

    html += `<div class="grid grid-cols-2 gap-4 mt-4">
        ${collapsible('Georgia Turnover Plays', gf.flatMap(g => (g.play_tree||[]).flatMap(q => q.drives.flatMap(d => d.plays.filter(p => p.is_turnover)))).length, renderTurnoverTable(gf, 'team-a'))}
        ${collapsible('Arizona State Turnover Plays', af.flatMap(g => (g.play_tree||[]).flatMap(q => q.drives.flatMap(d => d.plays.filter(p => p.is_turnover)))).length, renderTurnoverTable(af, 'team-b'))}
    </div>`;

    html += `<div class="glass rounded-xl p-4 mt-6">
        <div class="text-sm text-zinc-300 font-medium mb-2">Season Trend</div>
        ${chartContainer('trendTurnovers', '280px')}
    </div>`;
    html += `</div>`;
    return html;
}

function initTurnoverCharts() {
    const gf = filterGames(DATA.teams.georgia.games), af = filterGames(DATA.teams.asu.games);
    const gIntLost = sumField(gf, 'interceptions_lost');
    const gIntGained = sumField(gf, 'interceptions_gained');
    const gFumLost = sumField(gf, 'fumbles_lost');
    const gFumGained = sumField(gf, 'fumbles_gained');
    const aIntLost = sumField(af, 'interceptions_lost');
    const aIntGained = sumField(af, 'interceptions_gained');
    const aFumLost = sumField(af, 'fumbles_lost');
    const aFumGained = sumField(af, 'fumbles_gained');
    const c = safeInitChart('toChart');
    if (c) safeSetOption(c, 'toChart', {
        backgroundColor: 'transparent',
        tooltip: { 
            trigger: 'axis',
            formatter: (params) => {
                const i = params[0].dataIndex;
                const gGame = gf[i];
                const aGame = af[i];
                let tip = '';
                params.forEach(p => {
                    const g = p.seriesName.includes('Georgia') ? gGame : aGame;
                    tip += `${p.marker} ${p.seriesName}: ${p.value}<br/>`;
                    if (g) tip += `vs ${g.opponent} ${g.date ? '(' + g.date + ')' : ''}<br/>`;
                });
                return tip;
            }
        },
        legend: { data: ['Georgia TO Margin', 'ASU TO Margin'], textStyle: { color: '#a1a1aa' } },
        xAxis: { type: 'category', data: gf.map((g,i) => 'G'+(i+1)), axisLabel: { color: '#71717a' } },
        yAxis: { type: 'value', axisLabel: { color: '#71717a' }, splitLine: { lineStyle: { color: 'rgba(255,255,255,0.05)' } } },
        series: [
            { name: 'Georgia TO Margin', type: 'bar', data: gf.map(g => g.turnovers_gained - g.turnovers_lost), itemStyle: { color: '#ef4444' } },
            { name: 'ASU TO Margin', type: 'bar', data: af.map(g => g.turnovers_gained - g.turnovers_lost), itemStyle: { color: '#f97316' } },
        ]
    });
    const cGained = safeInitChart('toSplitGained');
    if (cGained) safeSetOption(cGained, 'toSplitGained', {
        backgroundColor: 'transparent',
        tooltip: { trigger: 'axis' },
        legend: { data: ['INTs', 'Fumbles'], textStyle: { color: '#a1a1aa' } },
        grid: { left: 30, right: 20, top: 30, bottom: 30, containLabel: true },
        xAxis: { type: 'category', data: ['Georgia', 'ASU'], axisLabel: { color: '#71717a' } },
        yAxis: { type: 'value', axisLabel: { color: '#71717a' }, splitLine: { lineStyle: { color: 'rgba(255,255,255,0.05)' } } },
        series: [
            { name: 'INTs', type: 'bar', stack: 'gained', data: [gIntGained, aIntGained], itemStyle: { color: '#60a5fa' } },
            { name: 'Fumbles', type: 'bar', stack: 'gained', data: [gFumGained, aFumGained], itemStyle: { color: '#34d399' } },
        ]
    });
    const cLost = safeInitChart('toSplitLost');
    if (cLost) safeSetOption(cLost, 'toSplitLost', {
        backgroundColor: 'transparent',
        tooltip: { trigger: 'axis' },
        legend: { data: ['INTs', 'Fumbles'], textStyle: { color: '#a1a1aa' } },
        grid: { left: 30, right: 20, top: 30, bottom: 30, containLabel: true },
        xAxis: { type: 'category', data: ['Georgia', 'ASU'], axisLabel: { color: '#71717a' } },
        yAxis: { type: 'value', axisLabel: { color: '#71717a' }, splitLine: { lineStyle: { color: 'rgba(255,255,255,0.05)' } } },
        series: [
            { name: 'INTs', type: 'bar', stack: 'lost', data: [gIntLost, aIntLost], itemStyle: { color: '#93c5fd' } },
            { name: 'Fumbles', type: 'bar', stack: 'lost', data: [gFumLost, aFumLost], itemStyle: { color: '#86efac' } },
        ]
    });
    const charts = [c, cGained, cLost].filter(Boolean);
    window.addEventListener('resize', () => charts.forEach(ch => ch.resize()));
    initTrendsCharts();
}

function renderPostTurnover() {
    const ga = DATA.teams.georgia, aa = DATA.teams.asu;
    const gf = filterGames(ga.games), af = filterGames(aa.games);
    const gs = agg(gf), as_ = agg(af);
    const gq = makeQuality(gf);
    const aq = makeQuality(af);

    const gPointsOff = sumField(gf, 'points_off_turnovers_for');
    const aPointsOff = sumField(af, 'points_off_turnovers_for');
    const gPointsAllowed = sumField(gf, 'points_off_turnovers_against');
    const aPointsAllowed = sumField(af, 'points_off_turnovers_against');
    const gPointsOffInt = sumPostTurnoverPointsByType(gf, 'INT', ga.abbr);
    const gPointsOffFum = sumPostTurnoverPointsByType(gf, 'FUM', ga.abbr);
    const aPointsOffInt = sumPostTurnoverPointsByType(af, 'INT', aa.abbr);
    const aPointsOffFum = sumPostTurnoverPointsByType(af, 'FUM', aa.abbr);

    let html = `<div class="section-enter">`;
    html += fourthDownNote();
    html += `<div class="grid grid-cols-2 gap-4 mb-6">
        <div class="grid grid-cols-5 gap-3">
            ${statCard('TO Gained', gs.tof, '', 'team-a', gq(['turnovers_gained'], 'TO Gained'))}
            ${statCard('TO Lost', gs.tol, '', 'team-a', gq(['turnovers_lost'], 'TO Lost'))}
            ${statCard('Pts Off INT', gPointsOffInt, '', 'team-a', gq(['post_turnover_drives'], 'Pts Off INT'))}
            ${statCard('Pts Off FUM', gPointsOffFum, '', 'team-a', gq(['post_turnover_drives'], 'Pts Off FUM'))}
            ${statCard('Pts Off TO', gPointsOff, '', 'team-a', gq(['points_off_turnovers_for'], 'Pts Off TO'))}
        </div>
        <div class="grid grid-cols-5 gap-3">
            ${statCard('TO Gained', as_.tof, '', 'team-b', aq(['turnovers_gained'], 'TO Gained'))}
            ${statCard('TO Lost', as_.tol, '', 'team-b', aq(['turnovers_lost'], 'TO Lost'))}
            ${statCard('Pts Off INT', aPointsOffInt, '', 'team-b', aq(['post_turnover_drives'], 'Pts Off INT'))}
            ${statCard('Pts Off FUM', aPointsOffFum, '', 'team-b', aq(['post_turnover_drives'], 'Pts Off FUM'))}
            ${statCard('Pts Off TO', aPointsOff, '', 'team-b', aq(['points_off_turnovers_for'], 'Pts Off TO'))}
        </div>
    </div>`;
    
    html += compBar('Points Off Turnovers', gPointsOff, aPointsOff);
    html += compBar('Points Allowed After TO', gPointsAllowed, aPointsAllowed);
    html += `<div class="grid grid-cols-2 gap-4 mt-4">
        <div class="glass rounded-xl p-4">${chartContainer('postToTotalsChart', '260px')}</div>
        <div class="glass rounded-xl p-4">${chartContainer('postToPerGameChart', '260px')}</div>
    </div>`;

    // Post-turnover drive tables (collapsed by default)
    const renderPostTurnoverTable = games => {
        const drives = games.flatMap(g => {
            return (g.post_turnover_drives || []).map(d => ({...d, game: g.game_number, opponent: g.opponent}));
        });

        if (!drives.length) {
            return { count: 0, content: `<div class="text-zinc-500 text-xs p-4">No post-turnover drives recorded.</div>` };
        }

        const table = `<table class="w-full text-xs"><thead class="sticky top-0 bg-zinc-900"><tr>
            <th class="py-2 px-2 text-left text-zinc-500">G#</th>
            <th class="py-2 px-2 text-left text-zinc-500">Opponent</th>
            <th class="py-2 px-2 text-left text-zinc-500">Q</th>
            <th class="py-2 px-2 text-left text-zinc-500">Clock</th>
            <th class="py-2 px-2 text-left text-zinc-500">Type</th>
            <th class="py-2 px-2 text-left text-zinc-500">Lost By</th>
            <th class="py-2 px-2 text-left text-zinc-500">Recovered By</th>
            <th class="py-2 px-2 text-left text-zinc-500">Result</th>
            <th class="py-2 px-2 text-left text-zinc-500">Points</th>
            <th class="py-2 px-2 text-left text-zinc-500">Description</th>
        </tr></thead><tbody>${drives.map(d => `<tr class="border-t border-white/5 hover:bg-white/5">
            <td class="py-2 px-2">${d.game}</td>
            <td class="py-2 px-2">${d.opponent}</td>
            <td class="py-2 px-2">${d.quarter}</td>
            <td class="py-2 px-2">${d.clock}</td>
            <td class="py-2 px-2">${d.turnover_type}</td>
            <td class="py-2 px-2">${d.lost_by}</td>
            <td class="py-2 px-2">${d.recovered_by}</td>
            <td class="py-2 px-2">${d.drive_result}</td>
            <td class="py-2 px-2">${d.points_scored || 0}</td>
            <td class="py-2 px-2 text-zinc-400">${d.turnover_description}</td>
        </tr>`).join('')}</tbody></table>`;

        return { count: drives.length, content: table };
    };

    const gPostTo = renderPostTurnoverTable(gf);
    const aPostTo = renderPostTurnoverTable(af);

    html += `<div class="grid grid-cols-2 gap-4 mt-4">
        ${collapsible(`${ga.name} Post-Turnover Drives`, gPostTo.count, gPostTo.content)}
        ${collapsible(`${aa.name} Post-Turnover Drives`, aPostTo.count, aPostTo.content)}
    </div>`;

    html += `</div>`;
    return html;
}

function initPostTurnoverCharts() {
    const ga = DATA.teams.georgia, aa = DATA.teams.asu;
    const gf = filterGames(ga.games), af = filterGames(aa.games);
    const gPointsOffInt = sumPostTurnoverPointsByType(gf, 'INT', ga.abbr);
    const gPointsOffFum = sumPostTurnoverPointsByType(gf, 'FUM', ga.abbr);
    const aPointsOffInt = sumPostTurnoverPointsByType(af, 'INT', aa.abbr);
    const aPointsOffFum = sumPostTurnoverPointsByType(af, 'FUM', aa.abbr);
    const maxGames = Math.max(gf.length, af.length);
    const labels = Array.from({length: maxGames}, (_,i) => `G${i+1}`);
    const gIntByGame = Array.from({length: maxGames}, (_,i) => sumPostTurnoverPoints(gf[i], 'INT', ga.abbr));
    const gFumByGame = Array.from({length: maxGames}, (_,i) => sumPostTurnoverPoints(gf[i], 'FUM', ga.abbr));
    const aIntByGame = Array.from({length: maxGames}, (_,i) => sumPostTurnoverPoints(af[i], 'INT', aa.abbr));
    const aFumByGame = Array.from({length: maxGames}, (_,i) => sumPostTurnoverPoints(af[i], 'FUM', aa.abbr));
    const totalsChart = safeInitChart('postToTotalsChart');
    if (totalsChart) safeSetOption(totalsChart, 'postToTotalsChart', {
        backgroundColor: 'transparent',
        tooltip: { trigger: 'axis' },
        legend: { data: ['Pts Off INT', 'Pts Off FUM'], textStyle: { color: '#a1a1aa' } },
        grid: { left: 30, right: 20, top: 30, bottom: 30, containLabel: true },
        xAxis: { type: 'category', data: [ga.name, aa.name], axisLabel: { color: '#71717a' } },
        yAxis: { type: 'value', axisLabel: { color: '#71717a' }, splitLine: { lineStyle: { color: 'rgba(255,255,255,0.05)' } } },
        series: [
            { name: 'Pts Off INT', type: 'bar', stack: 'points', data: [gPointsOffInt, aPointsOffInt], itemStyle: { color: '#ef4444' } },
            { name: 'Pts Off FUM', type: 'bar', stack: 'points', data: [gPointsOffFum, aPointsOffFum], itemStyle: { color: '#fca5a5' } },
        ]
    });
    const perGameChart = safeInitChart('postToPerGameChart');
    if (perGameChart) safeSetOption(perGameChart, 'postToPerGameChart', {
        backgroundColor: 'transparent',
        tooltip: { trigger: 'axis' },
        legend: { data: ['UGA INT', 'UGA FUM', 'ASU INT', 'ASU FUM'], textStyle: { color: '#a1a1aa' } },
        grid: { left: 30, right: 20, top: 30, bottom: 30, containLabel: true },
        xAxis: { type: 'category', data: labels, axisLabel: { color: '#71717a' } },
        yAxis: { type: 'value', axisLabel: { color: '#71717a' }, splitLine: { lineStyle: { color: 'rgba(255,255,255,0.05)' } } },
        series: [
            { name: 'UGA INT', type: 'bar', stack: 'UGA', data: gIntByGame, itemStyle: { color: '#ef4444' } },
            { name: 'UGA FUM', type: 'bar', stack: 'UGA', data: gFumByGame, itemStyle: { color: '#fca5a5' } },
            { name: 'ASU INT', type: 'bar', stack: 'ASU', data: aIntByGame, itemStyle: { color: '#f97316' } },
            { name: 'ASU FUM', type: 'bar', stack: 'ASU', data: aFumByGame, itemStyle: { color: '#fdba74' } },
        ]
    });
    const charts = [totalsChart, perGameChart].filter(Boolean);
    window.addEventListener('resize', () => charts.forEach(ch => ch.resize()));
}

function renderPenalties() {
    const gf = filterGames(DATA.teams.georgia.games), af = filterGames(DATA.teams.asu.games);
    const gs = agg(gf), as_ = agg(af);
    const ga = DATA.teams.georgia, aa = DATA.teams.asu;
    const gq = makeQuality(gf);
    const aq = makeQuality(af);
    const HOLDING_OFF_LABEL = 'Offensive Holding (10y)';
    const HOLDING_DEF_LABEL = 'Defensive Holding (5y, AFD)';
    const getPenaltyDetails = (games) => games.flatMap(g => (g.penalty_details || []).map(p => ({
        ...p,
        game: g.game_number,
        opponent: g.opponent
    })));
    const gaDetails = getPenaltyDetails(gf).filter(p => p.team === ga.abbr);
    const aaDetails = getPenaltyDetails(af).filter(p => p.team === aa.abbr);
    const gaOffensePens = gaDetails.filter(p => p.offense_or_defense === 'offense').length;
    const gaDefensePens = gaDetails.filter(p => p.offense_or_defense === 'defense').length;
    const aaOffensePens = aaDetails.filter(p => p.offense_or_defense === 'offense').length;
    const aaDefensePens = aaDetails.filter(p => p.offense_or_defense === 'defense').length;
    const classifyPenalty = (p) => {
        const text = `${p.type || ''} ${p.description || ''}`.toLowerCase();
        if (text.includes('holding')) {
            if (p.offense_or_defense === 'offense') return HOLDING_OFF_LABEL;
            if (p.offense_or_defense === 'defense') return HOLDING_DEF_LABEL;
            return 'Holding';
        }
        if (text.includes('pass interference') || /\b(dpi|opi)\b/.test(text)) return 'Pass Interference';
        if (text.includes('false start')) return 'False Start';
        if (text.includes('offside')) return 'Offsides/Offside';
        if (text.includes('illegal formation')) return 'Illegal Formation';
        if (text.includes('unsportsmanlike')) return 'Unsportsmanlike';
        return 'Other';
    };
    const extractPenaltyNames = (desc) => {
        if (!desc || typeof desc !== 'string') return [];
        const penaltyIdx = desc.toUpperCase().indexOf('PENALTY');
        const searchText = penaltyIdx >= 0 ? desc.slice(penaltyIdx) : desc;
        const matches = [];
        let m;
        const re = /\(([^)]+)\)/g;
        while ((m = re.exec(searchText)) !== null) {
            matches.push(m[1]);
        }
        if (!matches.length) return [];
        return matches.flatMap(chunk => chunk.split(/\/|&| and |;|\|/i))
            .map(part => part.trim())
            .filter(part => /[a-z]/i.test(part))
            .map(part => {
                if (part.includes(',')) {
                    const parts = part.split(',').map(s => s.trim()).filter(Boolean);
                    if (parts.length >= 2) return `${parts[1]} ${parts[0]}`.trim();
                }
                return part;
            })
            .filter(name => name.length >= 3);
    };
    const typeBuckets = [HOLDING_OFF_LABEL, HOLDING_DEF_LABEL, 'Holding', 'Pass Interference', 'False Start', 'Offsides/Offside', 'Illegal Formation', 'Unsportsmanlike', 'Other'];
    const renderPenaltyTypeList = (details, side, teamClass) => {
        const filtered = details.filter(p => (p.offense_or_defense || 'unknown') === side);
        if (!filtered.length) return `<div class="text-zinc-500 text-xs">No ${side} penalties.</div>`;
        const counts = filtered.reduce((acc, p) => {
            const bucket = classifyPenalty(p);
            acc[bucket] = (acc[bucket] || 0) + 1;
            return acc;
        }, {});
        const rows = typeBuckets.filter(t => counts[t]).map(t => (
            `<div class="flex items-center justify-between text-xs">
                <span class="text-zinc-300">${t}</span>
                <span class="${teamClass}">${counts[t]}</span>
            </div>`
        )).join('');
        return rows || `<div class="text-zinc-500 text-xs">No ${side} penalties.</div>`;
    };
    const renderOffenders = (details, teamClass) => {
        const counts = {};
        details.forEach(p => {
            extractPenaltyNames(p.description).forEach(name => {
                counts[name] = (counts[name] || 0) + 1;
            });
        });
        const top = Object.entries(counts).sort((a,b) => b[1] - a[1]).slice(0,5);
        if (!top.length) return `<div class="text-zinc-500 text-xs p-4">No player penalties found.</div>`;
        return `<div class="space-y-2">
            ${top.map((t,i) => `<div class="flex items-center justify-between text-sm">
                <span class="${teamClass}">${i+1}. ${t[0]}</span>
                <span class="text-zinc-500">${t[1]}</span>
            </div>`).join('')}
        </div>`;
    };

    let html = `<div class="section-enter">`;
    html += fourthDownNote();
    html += `<div class="grid grid-cols-2 gap-4 mb-6">
        <div class="grid grid-cols-3 gap-3">
            ${statCard('Penalties/Game', gs.penpg, gs.pen+' total', 'team-a', gq(['penalties'], 'Penalties/Game'), buildStatBadge(ga, 'penalties'))}
            ${statCard('Offense Pens', gaOffensePens, '', 'team-a', gq(['penalty_details'], 'Offense Pens'))}
            ${statCard('Defense Pens', gaDefensePens, '', 'team-a', gq(['penalty_details'], 'Defense Pens'))}
        </div>
        <div class="grid grid-cols-3 gap-3">
            ${statCard('Penalties/Game', as_.penpg, as_.pen+' total', 'team-b', aq(['penalties'], 'Penalties/Game'), buildStatBadge(aa, 'penalties'))}
            ${statCard('Offense Pens', aaOffensePens, '', 'team-b', aq(['penalty_details'], 'Offense Pens'))}
            ${statCard('Defense Pens', aaDefensePens, '', 'team-b', aq(['penalty_details'], 'Defense Pens'))}
        </div>
    </div>`;
    html += compBar('Penalties/Game', gs.penpg, as_.penpg);
    html += `<div class="glass rounded-xl p-4 mt-4">${chartContainer('penChart')}</div>`;
    html += `<div class="grid grid-cols-2 gap-4 mt-4">
        <div class="glass rounded-xl p-4">${chartContainer('penTypeChart')}</div>
        <div class="glass rounded-xl p-4">${chartContainer('penAcceptChart', '260px')}</div>
    </div>`;
    html += `<div class="grid grid-cols-2 gap-4 mt-4">
        <div class="glass rounded-xl p-4">
            <div class="text-sm font-medium text-white mb-3">${ga.name} Biggest Offenders</div>
            ${renderOffenders(gaDetails, 'team-a')}
        </div>
        <div class="glass rounded-xl p-4">
            <div class="text-sm font-medium text-white mb-3">${aa.name} Biggest Offenders</div>
            ${renderOffenders(aaDetails, 'team-b')}
        </div>
    </div>`;
    html += `<div class="grid grid-cols-2 gap-4 mt-4">
        <div class="glass rounded-xl p-4">
            <div class="text-sm font-medium text-white mb-3">${ga.name} Penalty Breakdown</div>
            <div class="grid grid-cols-2 gap-3">
                <div>
                    <div class="text-xs text-zinc-500 mb-2">Offense</div>
                    <div class="space-y-1">${renderPenaltyTypeList(gaDetails, 'offense', 'team-a')}</div>
                </div>
                <div>
                    <div class="text-xs text-zinc-500 mb-2">Defense</div>
                    <div class="space-y-1">${renderPenaltyTypeList(gaDetails, 'defense', 'team-a')}</div>
                </div>
            </div>
        </div>
        <div class="glass rounded-xl p-4">
            <div class="text-sm font-medium text-white mb-3">${aa.name} Penalty Breakdown</div>
            <div class="grid grid-cols-2 gap-3">
                <div>
                    <div class="text-xs text-zinc-500 mb-2">Offense</div>
                    <div class="space-y-1">${renderPenaltyTypeList(aaDetails, 'offense', 'team-b')}</div>
                </div>
                <div>
                    <div class="text-xs text-zinc-500 mb-2">Defense</div>
                    <div class="space-y-1">${renderPenaltyTypeList(aaDetails, 'defense', 'team-b')}</div>
                </div>
            </div>
        </div>
    </div>`;
    const sortPenalties = (details) => details.slice().sort((a, b) => {
        if ((a.game || 0) !== (b.game || 0)) return (a.game || 0) - (b.game || 0);
        if ((a.quarter || 0) !== (b.quarter || 0)) return (a.quarter || 0) - (b.quarter || 0);
        return (a.clock || '').localeCompare(b.clock || '');
    });
    const renderPenaltyDetailsTable = (details, teamClass) => {
        if (!details.length) return `<div class="text-zinc-500 text-xs p-4">No penalty details found.</div>`;
        return `<table class="w-full text-xs"><thead class="sticky top-0 bg-zinc-900"><tr>
            <th class="py-2 px-2 text-left text-zinc-500">G#</th>
            <th class="py-2 px-2 text-left text-zinc-500">Opponent</th>
            <th class="py-2 px-2 text-left text-zinc-500">Quarter</th>
            <th class="py-2 px-2 text-left text-zinc-500">Clock</th>
            <th class="py-2 px-2 text-left text-zinc-500">Side</th>
            <th class="py-2 px-2 text-left text-zinc-500">Type</th>
            <th class="py-2 px-2 text-right text-zinc-500">Yds</th>
            <th class="py-2 px-2 text-left text-zinc-500">Accepted</th>
            <th class="py-2 px-2 text-left text-zinc-500">Description</th>
        </tr></thead><tbody>${sortPenalties(details).map(p => `<tr class="border-b border-white/5 table-row">
            <td class="py-1 px-2 text-zinc-400">G${p.game}</td>
            <td class="py-1 px-2">${p.opponent||''}</td>
            <td class="py-1 px-2">${p.quarter}</td>
            <td class="py-1 px-2 text-zinc-400">${p.clock||''}</td>
            <td class="py-1 px-2 text-zinc-400">${(p.offense_or_defense || 'unknown').replace(/^\w/, c => c.toUpperCase())}</td>
            <td class="py-1 px-2 ${teamClass}">${classifyPenalty(p)}</td>
            <td class="py-1 px-2 text-right text-zinc-400">${p.yards || 0}</td>
            <td class="py-1 px-2 text-zinc-400">${p.accepted ? 'Yes' : 'No'}</td>
            <td class="py-1 px-2 text-zinc-300">${(p.description||'').substring(0,100)}</td>
        </tr>`).join('')}</tbody></table>`;
    };

    html += `<div class="grid grid-cols-2 gap-4 mt-4">
        ${collapsible(`${ga.name} Penalty Details`, gaDetails.length, renderPenaltyDetailsTable(gaDetails, 'team-a'))}
        ${collapsible(`${aa.name} Penalty Details`, aaDetails.length, renderPenaltyDetailsTable(aaDetails, 'team-b'))}
    </div>`;

    // Penalty play details
    const renderPenaltyTable = (games, teamClass) => {
        const penPlays = games.flatMap((g,idx) => {
            return (g.play_tree||[]).flatMap(q => 
                q.drives.flatMap(d => 
                    d.plays.filter(p => (p.description||'').toUpperCase().includes('PENALTY'))
                        .map(p => ({...p, game: g.game_number, opponent: g.opponent}))
                )
            );
        });
        if (!penPlays.length) return `<div class="text-zinc-500 text-xs p-4">No penalty plays found.</div>`;
        return `<table class="w-full text-xs"><thead class="sticky top-0 bg-zinc-900"><tr>
            <th class="py-2 px-2 text-left text-zinc-500">G#</th>
            <th class="py-2 px-2 text-left text-zinc-500">Opponent</th>
            <th class="py-2 px-2 text-left text-zinc-500">Quarter</th>
            <th class="py-2 px-2 text-left text-zinc-500">Clock</th>
            <th class="py-2 px-2 text-left text-zinc-500">Down/Dist</th>
            <th class="py-2 px-2 text-left text-zinc-500">Spot</th>
            <th class="py-2 px-2 text-left text-zinc-500">Description</th>
        </tr></thead><tbody>${penPlays.map(p => `<tr class="border-b border-white/5 table-row">
            <td class="py-1 px-2 text-zinc-400">G${p.game}</td>
            <td class="py-1 px-2">${p.opponent||''}</td>
            <td class="py-1 px-2">${p.quarter}</td>
            <td class="py-1 px-2 text-zinc-400">${p.clock||''}</td>
            <td class="py-1 px-2 text-zinc-400">${p.down_distance||''}</td>
            <td class="py-1 px-2 text-zinc-400">${p.spot||''}</td>
            <td class="py-1 px-2 text-zinc-300">${(p.description||'').substring(0,120)}</td>
        </tr>`).join('')}</tbody></table>`;
    };

    html += `<div class="grid grid-cols-2 gap-4 mt-4">
        ${collapsible('Georgia Penalty Plays', gf.flatMap(g => (g.play_tree||[]).flatMap(q => q.drives.flatMap(d => d.plays.filter(p => (p.description||'').toUpperCase().includes('PENALTY'))))).length, renderPenaltyTable(gf, 'team-a'))}
        ${collapsible('Arizona State Penalty Plays', af.flatMap(g => (g.play_tree||[]).flatMap(q => q.drives.flatMap(d => d.plays.filter(p => (p.description||'').toUpperCase().includes('PENALTY'))))).length, renderPenaltyTable(af, 'team-b'))}
    </div>`;

    html += `<div class="glass rounded-xl p-4 mt-6">
        <div class="text-sm text-zinc-300 font-medium mb-2">Season Trend</div>
        ${chartContainer('trendPenalties', '280px')}
    </div>`;
    html += `</div>`;
    return html;
}

function initPenaltyCharts() {
    const gf = filterGames(DATA.teams.georgia.games), af = filterGames(DATA.teams.asu.games);
    const ga = DATA.teams.georgia, aa = DATA.teams.asu;
    const HOLDING_OFF_LABEL = 'Offensive Holding (10y)';
    const HOLDING_DEF_LABEL = 'Defensive Holding (5y, AFD)';
    const getPenaltyDetails = (games) => games.flatMap(g => (g.penalty_details || []).map(p => ({
        ...p,
        game: g.game_number,
        opponent: g.opponent
    })));
    const classifyPenalty = (p) => {
        const text = `${p.type || ''} ${p.description || ''}`.toLowerCase();
        if (text.includes('holding')) {
            if (p.offense_or_defense === 'offense') return HOLDING_OFF_LABEL;
            if (p.offense_or_defense === 'defense') return HOLDING_DEF_LABEL;
            return 'Holding';
        }
        if (text.includes('pass interference') || /\b(dpi|opi)\b/.test(text)) return 'Pass Interference';
        if (text.includes('false start')) return 'False Start';
        if (text.includes('offside')) return 'Offsides/Offside';
        if (text.includes('illegal formation')) return 'Illegal Formation';
        if (text.includes('unsportsmanlike')) return 'Unsportsmanlike';
        return 'Other';
    };
    const gaDetails = getPenaltyDetails(gf).filter(p => p.team === ga.abbr);
    const aaDetails = getPenaltyDetails(af).filter(p => p.team === aa.abbr);
    const typeBuckets = [HOLDING_OFF_LABEL, HOLDING_DEF_LABEL, 'Holding', 'Pass Interference', 'False Start', 'Offsides/Offside', 'Illegal Formation', 'Unsportsmanlike', 'Other'];
    const countByType = (details) => details.reduce((acc, p) => {
        const bucket = classifyPenalty(p);
        acc[bucket] = (acc[bucket] || 0) + 1;
        return acc;
    }, {});
    const gaTypeCounts = countByType(gaDetails);
    const aaTypeCounts = countByType(aaDetails);

    const c = safeInitChart('penChart');
    if (c) safeSetOption(c, 'penChart', {
        backgroundColor: 'transparent',
        tooltip: { 
            trigger: 'axis',
            formatter: (params) => {
                const i = params[0].dataIndex;
                const gGame = gf[i];
                const aGame = af[i];
                let tip = '';
                params.forEach(p => {
                    const g = p.seriesName === 'Georgia' ? gGame : aGame;
                    tip += `${p.marker} ${p.seriesName}: ${p.value}<br/>`;
                    if (g) tip += `vs ${g.opponent} ${g.date ? '(' + g.date + ')' : ''}<br/>`;
                });
                return tip;
            }
        },
        legend: { data: ['Georgia', 'Arizona State'], textStyle: { color: '#a1a1aa' } },
        xAxis: { type: 'category', data: gf.map((g,i) => 'G'+(i+1)), axisLabel: { color: '#71717a' } },
        yAxis: { type: 'value', axisLabel: { color: '#71717a' }, splitLine: { lineStyle: { color: 'rgba(255,255,255,0.05)' } } },
        series: [
            { name: 'Georgia', type: 'line', data: gf.map(g => g.penalties), itemStyle: { color: '#ef4444' }, smooth: true, areaStyle: { color: 'rgba(239,68,68,0.1)' } },
            { name: 'Arizona State', type: 'line', data: af.map(g => g.penalties), itemStyle: { color: '#f97316' }, smooth: true, areaStyle: { color: 'rgba(249,115,22,0.1)' } },
        ]
    });
    const typeChart = safeInitChart('penTypeChart');
    if (typeChart) {
        safeSetOption(typeChart, 'penTypeChart', {
            backgroundColor: 'transparent',
            tooltip: { trigger: 'axis', axisPointer: { type: 'shadow' } },
            legend: { data: [ga.name, aa.name], textStyle: { color: '#a1a1aa' } },
            grid: { left: '3%', right: '3%', bottom: '3%', containLabel: true },
            xAxis: { type: 'value', axisLabel: { color: '#71717a' }, splitLine: { lineStyle: { color: 'rgba(255,255,255,0.05)' } } },
            yAxis: { type: 'category', data: typeBuckets, axisLabel: { color: '#71717a' } },
            series: [
                { name: ga.name, type: 'bar', data: typeBuckets.map(t => gaTypeCounts[t] || 0), itemStyle: { color: '#ef4444' } },
                { name: aa.name, type: 'bar', data: typeBuckets.map(t => aaTypeCounts[t] || 0), itemStyle: { color: '#f97316' } },
            ]
        });
    }
    const acceptChart = safeInitChart('penAcceptChart');
    if (acceptChart) {
        const gaAccepted = gaDetails.filter(p => p.accepted).length;
        const gaDeclined = gaDetails.length - gaAccepted;
        const aaAccepted = aaDetails.filter(p => p.accepted).length;
        const aaDeclined = aaDetails.length - aaAccepted;
        safeSetOption(acceptChart, 'penAcceptChart', {
            backgroundColor: 'transparent',
            tooltip: { trigger: 'axis', axisPointer: { type: 'shadow' } },
            legend: { data: ['Accepted', 'Declined'], textStyle: { color: '#a1a1aa' } },
            grid: { left: '3%', right: '3%', bottom: '3%', containLabel: true },
            xAxis: { type: 'category', data: [ga.name, aa.name], axisLabel: { color: '#71717a' } },
            yAxis: { type: 'value', axisLabel: { color: '#71717a' }, splitLine: { lineStyle: { color: 'rgba(255,255,255,0.05)' } } },
            series: [
                { name: 'Accepted', type: 'bar', stack: 'total', data: [gaAccepted, aaAccepted], itemStyle: { color: '#22c55e' } },
                { name: 'Declined', type: 'bar', stack: 'total', data: [gaDeclined, aaDeclined], itemStyle: { color: '#ef4444' } },
            ]
        });
    }
    const charts = [c, typeChart, acceptChart].filter(Boolean);
    window.addEventListener('resize', () => charts.forEach(ch => ch.resize()));
    initTrendsCharts();
}

function renderSimpleTab(title, msg) {
    return `<div class="section-enter"><div class="glass rounded-xl p-8 text-center">
        <div class="text-2xl mb-2">${title}</div>
        <div class="text-zinc-500">${msg}</div>
    </div></div>`;
}

function renderMiddle8() {
    const ga = DATA.teams.georgia, aa = DATA.teams.asu;
    const gf = filterGames(ga.games), af = filterGames(aa.games);
    const gq = makeQuality(gf);
    const aq = makeQuality(af);
    const gaFor = sumField(gf, 'middle8_points_for');
    const gaAgainst = sumField(gf, 'middle8_points_against');
    const aaFor = sumField(af, 'middle8_points_for');
    const aaAgainst = sumField(af, 'middle8_points_against');

    let html = `<div class="section-enter">`;
    html += fourthDownNote();
    html += `<div class="grid grid-cols-2 gap-4 mb-6">
        <div class="grid grid-cols-3 gap-3">
            ${statCard('Middle 8 PF', gaFor, '', 'team-a', gq(['middle8_points_for'], 'Middle 8 PF'))}
            ${statCard('Middle 8 PA', gaAgainst, '', 'team-a', gq(['middle8_points_against'], 'Middle 8 PA'))}
            ${statCard('Middle 8 Diff', gaFor-gaAgainst, '', 'team-a', gq(['middle8_points_for','middle8_points_against'], 'Middle 8 Diff'))}
        </div>
        <div class="grid grid-cols-3 gap-3">
            ${statCard('Middle 8 PF', aaFor, '', 'team-b', aq(['middle8_points_for'], 'Middle 8 PF'))}
            ${statCard('Middle 8 PA', aaAgainst, '', 'team-b', aq(['middle8_points_against'], 'Middle 8 PA'))}
            ${statCard('Middle 8 Diff', aaFor-aaAgainst, '', 'team-b', aq(['middle8_points_for','middle8_points_against'], 'Middle 8 Diff'))}
        </div>
    </div>`;
    html += compBar('Middle 8 Point Diff', gaFor-gaAgainst, aaFor-aaAgainst);
    html += `<div class="glass rounded-xl p-4 mt-4">${chartContainer('middle8Chart')}</div>`;

    const parseClock = (clock) => {
        if (!clock || typeof clock !== 'string') return -1;
        const parts = clock.split(':').map(Number);
        if (parts.length !== 2 || parts.some(n => Number.isNaN(n))) return -1;
        return parts[0] * 60 + parts[1];
    };
    const sortPlays = (plays) => plays.slice().sort((a, b) => {
        if ((a.game || 0) !== (b.game || 0)) return (a.game || 0) - (b.game || 0);
        if ((a.quarter || 0) !== (b.quarter || 0)) return (a.quarter || 0) - (b.quarter || 0);
        return parseClock(b.clock) - parseClock(a.clock);
    });

    const gaPlays = sortPlays(gf.flatMap(g => (g.middle8_scoring_plays||[]).filter(p => p.team === ga.abbr).map(p => ({...p, opponent: g.opponent, game: g.game_number}))));
    const aaPlays = sortPlays(af.flatMap(g => (g.middle8_scoring_plays||[]).filter(p => p.team === aa.abbr).map(p => ({...p, opponent: g.opponent, game: g.game_number}))));

    const renderPlays = (plays, teamClass, teamAbbr) => {
        if (!plays.length) return `<div class="text-zinc-500 text-xs p-4">No middle 8 scoring plays found.</div>`;
        return `<table class="w-full text-xs"><thead class="sticky top-0 bg-zinc-900"><tr>
            <th class="py-2 px-2 text-left text-zinc-500">G#</th>
            <th class="py-2 px-2 text-left text-zinc-500">Opponent</th>
            <th class="py-2 px-2 text-left text-zinc-500">Quarter</th>
            <th class="py-2 px-2 text-left text-zinc-500">Clock</th>
            <th class="py-2 px-2 text-left text-zinc-500">Team</th>
            <th class="py-2 px-2 text-right text-zinc-500">Points</th>
            <th class="py-2 px-2 text-right text-zinc-500">Points Against</th>
            <th class="py-2 px-2 text-left text-zinc-500">Description</th>
        </tr></thead><tbody>${plays.map(p => `<tr class="border-b border-white/5 table-row">
            <td class="py-1 px-2 text-zinc-400">G${p.game}</td>
            <td class="py-1 px-2">${p.opponent||''}</td>
            <td class="py-1 px-2">${p.quarter}</td>
            <td class="py-1 px-2 text-zinc-400">${p.clock||''}</td>
            <td class="py-1 px-2 ${teamClass}">${p.team||''}</td>
            <td class="py-1 px-2 text-right font-bold">${p.points}</td>
            <td class="py-1 px-2 text-right text-zinc-400">${p.team && p.team !== teamAbbr ? p.points : 0}</td>
            <td class="py-1 px-2 text-zinc-400">${(p.description||'').substring(0,90)}</td>
        </tr>`).join('')}</tbody></table>`;
    };

    html += `<div class="grid grid-cols-2 gap-4 mt-4">
        ${collapsible('Georgia Middle 8 Scoring Plays', gaPlays.length, renderPlays(gaPlays, 'team-a', ga.abbr))}
        ${collapsible('Arizona State Middle 8 Scoring Plays', aaPlays.length, renderPlays(aaPlays, 'team-b', aa.abbr))}
    </div>`;

    html += `</div>`;
    return html;
}

function initMiddle8Charts() {
    const gf = filterGames(DATA.teams.georgia.games), af = filterGames(DATA.teams.asu.games);
    const c = safeInitChart('middle8Chart');
    if (!c) return;
    safeSetOption(c, 'middle8Chart', {
        backgroundColor: 'transparent',
        tooltip: { 
            trigger: 'axis',
            formatter: (params) => {
                const i = params[0].dataIndex;
                const gGame = gf[i];
                const aGame = af[i];
                let tip = '';
                params.forEach(p => {
                    const g = p.seriesName === 'Georgia' ? gGame : aGame;
                    tip += `${p.marker} ${p.seriesName}: ${p.value}<br/>`;
                    if (g) tip += `vs ${g.opponent} ${g.date ? '(' + g.date + ')' : ''}<br/>`;
                });
                return tip;
            }
        },
        legend: { data: ['Georgia', 'Arizona State'], textStyle: { color: '#a1a1aa' } },
        xAxis: { type: 'category', data: gf.map((g,i) => 'G'+(i+1)), axisLabel: { color: '#71717a' } },
        yAxis: { type: 'value', axisLabel: { color: '#71717a' }, splitLine: { lineStyle: { color: 'rgba(255,255,255,0.05)' } } },
        series: [
            { name: 'Georgia', type: 'bar', data: gf.map(g => (g.middle8_points_for||0) - (g.middle8_points_against||0)), itemStyle: { color: '#ef4444' } },
            { name: 'Arizona State', type: 'bar', data: af.map(g => (g.middle8_points_for||0) - (g.middle8_points_against||0)), itemStyle: { color: '#f97316' } }
        ]
    });
    window.addEventListener('resize', () => c.resize());
}

function renderFourthDown() {
    const gf = filterGames(DATA.teams.georgia.games), af = filterGames(DATA.teams.asu.games);
    const gq = makeQuality(gf);
    const aq = makeQuality(af);
    const gaAtt = sumField(gf, '4th_down_attempts');
    const gaConv = sumField(gf, '4th_down_conversions');
    const aaAtt = sumField(af, '4th_down_attempts');
    const aaConv = sumField(af, '4th_down_conversions');
    const gaPct = gaAtt ? (gaConv/gaAtt*100).toFixed(1) : '0.0';
    const aaPct = aaAtt ? (aaConv/aaAtt*100).toFixed(1) : '0.0';

    let html = `<div class="section-enter">`;
    html += fourthDownNote();
    html += `<div class="grid grid-cols-2 gap-4 mb-6">
        <div class="grid grid-cols-3 gap-3">
            ${statCard('4th Att', gaAtt, '', 'team-a', gq(['4th_down_attempts'], '4th Att'))}
            ${statCard('4th Conv', gaConv, gaPct+'%', 'team-a', gq(['4th_down_conversions'], '4th Conv'))}
            ${statCard('Conv %', gaPct, '', 'team-a', gq(['4th_down_attempts','4th_down_conversions'], 'Conv %'), buildStatBadge(ga, 'fourth_down'))}
        </div>
        <div class="grid grid-cols-3 gap-3">
            ${statCard('4th Att', aaAtt, '', 'team-b', aq(['4th_down_attempts'], '4th Att'))}
            ${statCard('4th Conv', aaConv, aaPct+'%', 'team-b', aq(['4th_down_conversions'], '4th Conv'))}
            ${statCard('Conv %', aaPct, '', 'team-b', aq(['4th_down_attempts','4th_down_conversions'], 'Conv %'), buildStatBadge(aa, 'fourth_down'))}
        </div>
    </div>`;
    html += compBar('4th Down Conversion %', Number(gaPct), Number(aaPct), '%');
    html += `<div class="glass rounded-xl p-4 mt-4">${chartContainer('fourthChart')}</div>`;

    const renderGameTable = (games, teamClass) => {
        return `<div class="glass rounded-xl overflow-hidden mt-4">
            <div class="px-4 py-3 border-b border-white/5"><span class="font-semibold ${teamClass}">By Game</span> <span class="text-zinc-500 text-sm">4th Down</span></div>
            <table class="w-full text-xs"><thead class="bg-zinc-900"><tr>
                <th class="py-2 px-2 text-left text-zinc-500">Gm</th>
                <th class="py-2 px-2 text-left text-zinc-500">Opp</th>
                <th class="py-2 px-2 text-right text-zinc-500">Att</th>
                <th class="py-2 px-2 text-right text-zinc-500">Conv</th>
                <th class="py-2 px-2 text-right text-zinc-500">%</th>
            </tr></thead><tbody>${games.map(g => {
                const att = g['4th_down_attempts'] || 0;
                const conv = g['4th_down_conversions'] || 0;
                const pct = att ? (conv/att*100).toFixed(1) : '0.0';
                return `<tr class="border-b border-white/5 table-row">
                    <td class="py-1 px-2 text-zinc-400">G${g.game_number}</td>
                    <td class="py-1 px-2">${g.opponent}</td>
                    <td class="py-1 px-2 text-right">${att}</td>
                    <td class="py-1 px-2 text-right font-bold">${conv}</td>
                    <td class="py-1 px-2 text-right text-zinc-400">${pct}%</td>
                </tr>`;
            }).join('')}</tbody></table>
        </div>`;
    };

    html += `<div class="grid grid-cols-2 gap-4 mt-4">
        ${renderGameTable(gf, 'team-a')}
        ${renderGameTable(af, 'team-b')}
    </div>`;

    // 4th down play details
    const render4thDownTable = (games, teamAbbr, teamClass) => {
        const fourthPlays = games.flatMap((g,idx) => {
            return (g.play_tree||[]).flatMap(q => 
                q.drives.flatMap(d => 
                    d.plays.filter(p => p.offense === teamAbbr && (p.down_distance||'').startsWith('4-'))
                        .map(p => ({...p, game: g.game_number, opponent: g.opponent}))
                )
            );
        });
        if (!fourthPlays.length) return `<div class="text-zinc-500 text-xs p-4">No 4th down plays found.</div>`;
        return `<table class="w-full text-xs"><thead class="sticky top-0 bg-zinc-900"><tr>
            <th class="py-2 px-2 text-left text-zinc-500">G#</th>
            <th class="py-2 px-2 text-left text-zinc-500">Opponent</th>
            <th class="py-2 px-2 text-left text-zinc-500">Quarter</th>
            <th class="py-2 px-2 text-left text-zinc-500">Clock</th>
            <th class="py-2 px-2 text-left text-zinc-500">Down/Dist</th>
            <th class="py-2 px-2 text-left text-zinc-500">Spot</th>
            <th class="py-2 px-2 text-right text-zinc-500">Yards</th>
            <th class="py-2 px-2 text-left text-zinc-500">Description</th>
        </tr></thead><tbody>${fourthPlays.map(p => {
            const conv = (p.description||'').includes('1ST DOWN');
            return `<tr class="border-b border-white/5 table-row">
                <td class="py-1 px-2 text-zinc-400">G${p.game}</td>
                <td class="py-1 px-2">${p.opponent||''}</td>
                <td class="py-1 px-2">${p.quarter}</td>
                <td class="py-1 px-2 text-zinc-400">${p.clock||''}</td>
                <td class="py-1 px-2 text-zinc-400">${p.down_distance||''}</td>
                <td class="py-1 px-2 text-zinc-400">${p.spot||''}</td>
                <td class="py-1 px-2 text-right font-bold ${conv?'text-green-400':'text-red-400'}">${p.yards||0}</td>
                <td class="py-1 px-2 text-zinc-300">${(p.description||'').substring(0,100)}</td>
            </tr>`;
        }).join('')}</tbody></table>`;
    };

    const ga = DATA.teams.georgia, aa = DATA.teams.asu;
    html += `<div class="grid grid-cols-2 gap-4 mt-4">
        ${collapsible('Georgia 4th Down Plays', gf.flatMap(g => (g.play_tree||[]).flatMap(q => q.drives.flatMap(d => d.plays.filter(p => p.offense === ga.abbr && (p.down_distance||'').startsWith('4-'))))).length, render4thDownTable(gf, ga.abbr, 'team-a'))}
        ${collapsible('Arizona State 4th Down Plays', af.flatMap(g => (g.play_tree||[]).flatMap(q => q.drives.flatMap(d => d.plays.filter(p => p.offense === aa.abbr && (p.down_distance||'').startsWith('4-'))))).length, render4thDownTable(af, aa.abbr, 'team-b'))}
    </div>`;

    html += `</div>`;
    return html;
}

function initFourthDownCharts() {
    const gf = filterGames(DATA.teams.georgia.games), af = filterGames(DATA.teams.asu.games);
    const c = safeInitChart('fourthChart');
    if (!c) return;
    safeSetOption(c, 'fourthChart', {
        backgroundColor: 'transparent',
        tooltip: { 
            trigger: 'axis',
            formatter: (params) => {
                const i = params[0].dataIndex;
                const gGame = gf[i];
                const aGame = af[i];
                let tip = '';
                params.forEach(p => {
                    const g = p.seriesName === 'Georgia' ? gGame : aGame;
                    tip += `${p.marker} ${p.seriesName}: ${p.value}%<br/>`;
                    if (g) tip += `vs ${g.opponent} ${g.date ? '(' + g.date + ')' : ''}<br/>`;
                });
                return tip;
            }
        },
        legend: { data: ['Georgia', 'Arizona State'], textStyle: { color: '#a1a1aa' } },
        xAxis: { type: 'category', data: gf.map((g,i) => 'G'+(i+1)), axisLabel: { color: '#71717a' } },
        yAxis: { type: 'value', axisLabel: { color: '#71717a', formatter: '{value}%' }, splitLine: { lineStyle: { color: 'rgba(255,255,255,0.05)' } } },
        series: [
            { name: 'Georgia', type: 'line', data: gf.map(g => {
                const att = g['4th_down_attempts'] || 0;
                const conv = g['4th_down_conversions'] || 0;
                return att ? +(conv/att*100).toFixed(1) : 0;
            }), itemStyle: { color: '#ef4444' }, smooth: true },
            { name: 'Arizona State', type: 'line', data: af.map(g => {
                const att = g['4th_down_attempts'] || 0;
                const conv = g['4th_down_conversions'] || 0;
                return att ? +(conv/att*100).toFixed(1) : 0;
            }), itemStyle: { color: '#f97316' }, smooth: true },
        ]
    });
    window.addEventListener('resize', () => c.resize());
}

function renderSpecialTeams() {
    const gf = filterGames(DATA.teams.georgia.games), af = filterGames(DATA.teams.asu.games);
    const gq = makeQuality(gf);
    const aq = makeQuality(af);
    const buildStBreakdown = (games, getter) => games.map(g => {
        const st = g.special_teams || {};
        const value = Number(getter(st, g) || 0);
        if (value <= 0) return null;
        return {
            game_number: g.game_number,
            opponent: g.opponent,
            opponent_abbr: g.opponent_abbr,
            date: g.date,
            value,
        };
    }).filter(Boolean);
    
    // Aggregate special teams data
    const gPunts = sumSpecial(gf, 'punts');
    const gPuntYds = sumSpecial(gf, 'punt_yards');
    const gPuntNetYds = sumSpecial(gf, 'punt_net_yards');
    const gPuntAvg = gPunts ? (gPuntYds / gPunts).toFixed(1) : '0.0';
    const gPuntInside20 = sumSpecial(gf, 'punts_inside_20');
    const gPuntTouchbacks = sumSpecial(gf, 'punt_touchbacks');
    
    const aPunts = sumSpecial(af, 'punts');
    const aPuntYds = sumSpecial(af, 'punt_yards');
    const aPuntNetYds = sumSpecial(af, 'punt_net_yards');
    const aPuntAvg = aPunts ? (aPuntYds / aPunts).toFixed(1) : '0.0';
    const aPuntInside20 = sumSpecial(af, 'punts_inside_20');
    const aPuntTouchbacks = sumSpecial(af, 'punt_touchbacks');
    
    const gFgMade = sumSpecial(gf, 'field_goals_made');
    const gFgAtt = sumSpecial(gf, 'field_goals_attempts');
    const gFgPct = gFgAtt ? (gFgMade / gFgAtt * 100).toFixed(1) : '0.0';
    const gFgMissed = gFgAtt - gFgMade;
    const gFgLong = maxSpecial(gf, 'field_goal_long');
    
    const aFgMade = sumSpecial(af, 'field_goals_made');
    const aFgAtt = sumSpecial(af, 'field_goals_attempts');
    const aFgPct = aFgAtt ? (aFgMade / aFgAtt * 100).toFixed(1) : '0.0';
    const aFgMissed = aFgAtt - aFgMade;
    const aFgLong = maxSpecial(af, 'field_goal_long');
    
    const gKo30 = sumSpecial(gf, 'kick_return_30_plus');
    const gPr20 = sumSpecial(gf, 'punt_return_20_plus');
    const gStTds = sumSpecial(gf, 'special_teams_tds');
    const gBlocks = sumSpecial(gf, 'fg_blocks') + sumSpecial(gf, 'punt_blocks');
    
    const aKo30 = sumSpecial(af, 'kick_return_30_plus');
    const aPr20 = sumSpecial(af, 'punt_return_20_plus');
    const aStTds = sumSpecial(af, 'special_teams_tds');
    const aBlocks = sumSpecial(af, 'fg_blocks') + sumSpecial(af, 'punt_blocks');

    let html = `<div class="section-enter">`;
    
    // Punting section
    html += `<div class="glass rounded-xl p-4 mb-4"><div class="text-sm font-medium text-white mb-3">Punting</div>`;
    html += `<div class="grid grid-cols-2 gap-4">
        <div class="grid grid-cols-3 gap-3">
            ${statCard('Punts', gPunts, '', 'team-a', gq(['special_teams.punts'], 'Punts'))}
            ${statCard('Gross Yds', gPuntYds, '', 'team-a', gq(['special_teams.punt_yards'], 'Gross Yds'))}
            ${statCard('Net Yds', gPuntNetYds, '', 'team-a', gq(['special_teams.punt_net_yards'], 'Net Yds'))}
            ${statCard('Avg', gPuntAvg, '', 'team-a', gq(['special_teams.punts','special_teams.punt_yards'], 'Avg'))}
            ${statCard('Inside 20', gPuntInside20, '', 'team-a', gq(['special_teams.punts_inside_20'], 'Inside 20'))}
            ${statCard('Touchbacks', gPuntTouchbacks, '', 'team-a', gq(['special_teams.punt_touchbacks'], 'Touchbacks'))}
        </div>
        <div class="grid grid-cols-3 gap-3">
            ${statCard('Punts', aPunts, '', 'team-b', aq(['special_teams.punts'], 'Punts'))}
            ${statCard('Gross Yds', aPuntYds, '', 'team-b', aq(['special_teams.punt_yards'], 'Gross Yds'))}
            ${statCard('Net Yds', aPuntNetYds, '', 'team-b', aq(['special_teams.punt_net_yards'], 'Net Yds'))}
            ${statCard('Avg', aPuntAvg, '', 'team-b', aq(['special_teams.punts','special_teams.punt_yards'], 'Avg'))}
            ${statCard('Inside 20', aPuntInside20, '', 'team-b', aq(['special_teams.punts_inside_20'], 'Inside 20'))}
            ${statCard('Touchbacks', aPuntTouchbacks, '', 'team-b', aq(['special_teams.punt_touchbacks'], 'Touchbacks'))}
        </div>
    </div></div>`;
    
    // Field Goals section
    html += `<div class="glass rounded-xl p-4 mb-4"><div class="text-sm font-medium text-white mb-3">Field Goals</div>`;
    html += `<div class="grid grid-cols-2 gap-4">
        <div class="grid grid-cols-3 gap-3">
            ${statCard('Att', gFgAtt, '', 'team-a', gq(['special_teams.field_goals_attempts'], 'FG Att'))}
            ${statCard('Made', gFgMade, '', 'team-a', gq(['special_teams.field_goals_made'], 'FG Made'))}
            ${statCard('Missed', gFgMissed, '', 'team-a', gq(['special_teams.field_goals_attempts','special_teams.field_goals_made'], 'FG Missed'))}
            ${statCard('FG %', gFgPct + '%', '', 'team-a', gq(['special_teams.field_goals_made','special_teams.field_goals_attempts'], 'FG %'))}
            ${statCard('Longest', gFgLong || '‚Äî', '', 'team-a', gq(['special_teams.field_goal_long'], 'FG Long'))}
        </div>
        <div class="grid grid-cols-3 gap-3">
            ${statCard('Att', aFgAtt, '', 'team-b', aq(['special_teams.field_goals_attempts'], 'FG Att'))}
            ${statCard('Made', aFgMade, '', 'team-b', aq(['special_teams.field_goals_made'], 'FG Made'))}
            ${statCard('Missed', aFgMissed, '', 'team-b', aq(['special_teams.field_goals_attempts','special_teams.field_goals_made'], 'FG Missed'))}
            ${statCard('FG %', aFgPct + '%', '', 'team-b', aq(['special_teams.field_goals_made','special_teams.field_goals_attempts'], 'FG %'))}
            ${statCard('Longest', aFgLong || '‚Äî', '', 'team-b', aq(['special_teams.field_goal_long'], 'FG Long'))}
        </div>
    </div></div>`;
    
    // Special teams explosives
    html += `<div class="glass rounded-xl p-4 mb-4"><div class="text-sm font-medium text-white mb-3">ST Explosives</div>`;
    html += `<div class="grid grid-cols-2 gap-4">
        <div class="grid grid-cols-2 gap-3">
            ${statCardWithBreakdown('Kick Return 30+', gKo30, '', 'team-a', gq(['special_teams.kick_return_30_plus'], 'Kick Return 30+'), buildStBreakdown(gf, st => st.kick_return_30_plus))}
            ${statCardWithBreakdown('Punt Return 20+', gPr20, '', 'team-a', gq(['special_teams.punt_return_20_plus'], 'Punt Return 20+'), buildStBreakdown(gf, st => st.punt_return_20_plus))}
            ${statCardWithBreakdown('ST TDs', gStTds, '', 'team-a', gq(['special_teams.special_teams_tds'], 'ST TDs'), buildStBreakdown(gf, st => st.special_teams_tds))}
            ${statCardWithBreakdown('Blocks', gBlocks, '', 'team-a', gq(['special_teams.fg_blocks','special_teams.punt_blocks'], 'Blocks'), buildStBreakdown(gf, st => (st.fg_blocks||0) + (st.punt_blocks||0)))}
        </div>
        <div class="grid grid-cols-2 gap-3">
            ${statCardWithBreakdown('Kick Return 30+', aKo30, '', 'team-b', aq(['special_teams.kick_return_30_plus'], 'Kick Return 30+'), buildStBreakdown(af, st => st.kick_return_30_plus))}
            ${statCardWithBreakdown('Punt Return 20+', aPr20, '', 'team-b', aq(['special_teams.punt_return_20_plus'], 'Punt Return 20+'), buildStBreakdown(af, st => st.punt_return_20_plus))}
            ${statCardWithBreakdown('ST TDs', aStTds, '', 'team-b', aq(['special_teams.special_teams_tds'], 'ST TDs'), buildStBreakdown(af, st => st.special_teams_tds))}
            ${statCardWithBreakdown('Blocks', aBlocks, '', 'team-b', aq(['special_teams.fg_blocks','special_teams.punt_blocks'], 'Blocks'), buildStBreakdown(af, st => (st.fg_blocks||0) + (st.punt_blocks||0)))}
        </div>
    </div></div>`;
    
    html += compBar('Punt Avg', Number(gPuntAvg), Number(aPuntAvg));
    html += compBar('FG %', Number(gFgPct), Number(aFgPct), '%');
    html += `<div class="glass rounded-xl p-4 mt-4">
        <div class="text-sm font-medium text-white mb-1">Return Yards by Game</div>
        <div class="text-xs text-zinc-500 mb-3">Kickoff + punt return yards</div>
        ${chartContainer('stChart')}
    </div>`;

    const renderStTable = (games, teamClass) => {
        return `<div class="glass rounded-xl overflow-hidden mt-4">
            <div class="px-4 py-3 border-b border-white/5"><span class="font-semibold ${teamClass}">By Game</span> <span class="text-zinc-500 text-sm">Special Teams</span></div>
            <table class="w-full text-xs"><thead class="bg-zinc-900"><tr>
                <th class="py-2 px-2 text-left text-zinc-500">Gm</th>
                <th class="py-2 px-2 text-left text-zinc-500">Opp</th>
                <th class="py-2 px-2 text-right text-zinc-500">KO 30+</th>
                <th class="py-2 px-2 text-right text-zinc-500">PR 20+</th>
                <th class="py-2 px-2 text-right text-zinc-500">ST TD</th>
                <th class="py-2 px-2 text-right text-zinc-500">Blocks</th>
            </tr></thead><tbody>${games.map(g => {
                const st = g.special_teams || {};
                const blocks = (st.fg_blocks||0) + (st.punt_blocks||0);
                return `<tr class="border-b border-white/5 table-row">
                    <td class="py-1 px-2 text-zinc-400">G${g.game_number}</td>
                    <td class="py-1 px-2">${g.opponent}</td>
                    <td class="py-1 px-2 text-right">${st.kick_return_30_plus||0}</td>
                    <td class="py-1 px-2 text-right">${st.punt_return_20_plus||0}</td>
                    <td class="py-1 px-2 text-right">${st.special_teams_tds||0}</td>
                    <td class="py-1 px-2 text-right">${blocks}</td>
                </tr>`;
            }).join('')}</tbody></table>
        </div>`;
    };

    html += `<div class="grid grid-cols-2 gap-4 mt-4">
        ${renderStTable(gf, 'team-a')}
        ${renderStTable(af, 'team-b')}
    </div>`;

    html += `</div>`;
    return html;
}

function initSpecialTeamsCharts() {
    const gf = filterGames(DATA.teams.georgia.games), af = filterGames(DATA.teams.asu.games);
    const c = safeInitChart('stChart');
    if (!c) return;
    safeSetOption(c, 'stChart', {
        backgroundColor: 'transparent',
        tooltip: { 
            trigger: 'axis',
            formatter: (params) => {
                const i = params[0].dataIndex;
                const gGame = gf[i];
                const aGame = af[i];
                let tip = '';
                params.forEach(p => {
                    const g = p.seriesName === 'Georgia' ? gGame : aGame;
                    tip += `${p.marker} ${p.seriesName}: ${p.value} yds<br/>`;
                    if (g) tip += `vs ${g.opponent} ${g.date ? '(' + g.date + ')' : ''}<br/>`;
                });
                return tip;
            }
        },
        legend: { data: ['Georgia', 'Arizona State'], textStyle: { color: '#a1a1aa' } },
        xAxis: { type: 'category', data: gf.map((g,i) => 'G'+(i+1)), axisLabel: { color: '#71717a' } },
        yAxis: { type: 'value', axisLabel: { color: '#71717a', formatter: '{value} yds' }, splitLine: { lineStyle: { color: 'rgba(255,255,255,0.05)' } } },
        series: [
            { name: 'Georgia', type: 'bar', data: gf.map(g => {
                const st = g.special_teams || {};
                return (st.kickoff_return_yards||0) + (st.punt_return_yards||0);
            }), itemStyle: { color: '#ef4444' } },
            { name: 'Arizona State', type: 'bar', data: af.map(g => {
                const st = g.special_teams || {};
                return (st.kickoff_return_yards||0) + (st.punt_return_yards||0);
            }), itemStyle: { color: '#f97316' } }
        ]
    });
    window.addEventListener('resize', () => c.resize());
}

function filterPlayTree(tree, query) {
    if (!query) return tree;
    const q = query.toLowerCase();
    return tree.map(qtr => {
        const drives = qtr.drives.map(d => {
            const plays = d.plays.filter(p => {
                const hay = [p.description, p.offense, p.down_distance, p.spot, p.clock].join(' ').toLowerCase();
                return hay.includes(q);
            });
            if (!plays.length) return null;
            return { drive_id: d.drive_id, offense: d.offense, plays };
        }).filter(Boolean);
        if (!drives.length) return null;
        return { quarter: qtr.quarter, drives };
    }).filter(Boolean);
}

function inferPlayType(play) {
    const desc = (play.description || '').toLowerCase();
    if (/(pass|sacked|sack|intercepted|complete|incomplete)/.test(desc)) return 'pass';
    if (/(rush|run)/.test(desc)) return 'rush';
    return 'other';
}

function isTouchdown(play) {
    return /touchdown/i.test(play.description || '');
}

function isBigPlay(play, type) {
    const yards = Math.abs(Number(play.yards || 0));
    if (!Number.isFinite(yards)) return false;
    if (type === 'pass') return yards >= 20;
    if (type === 'rush') return yards >= 15;
    return yards >= 20;
}

function buildPlayId(teamKey, gameNumber, quarter, driveId, seq) {
    return `${teamKey}-g${gameNumber}-q${quarter}-d${driveId}-s${seq}`;
}

function flattenPlayTree(game, teamKey, teamName, teamAbbr) {
    let seq = 0;
    const plays = [];
    const quarterEnds = [];
    (game.play_tree || []).forEach(q => {
        (q.drives || []).forEach(d => {
            (d.plays || []).forEach(p => {
                const type = inferPlayType(p);
                const id = buildPlayId(teamKey, game.game_number, p.quarter || q.quarter, d.drive_id, seq);
                plays.push({
                    ...p,
                    id,
                    seq,
                    type,
                    is_td: isTouchdown(p),
                    is_big: isBigPlay(p, type),
                    teamKey,
                    teamName,
                    teamAbbr,
                    game_number: game.game_number,
                    opponent: game.opponent,
                    date: game.date,
                    drive_id: d.drive_id
                });
                seq += 1;
            });
        });
        quarterEnds.push({ quarter: q.quarter, count: seq });
    });
    return { plays, totalPlays: seq, quarterEnds };
}

function playMatchesQuery(play, query) {
    if (!query) return true;
    const hay = [
        play.description,
        play.offense,
        play.down_distance,
        play.spot,
        play.clock
    ].join(' ').toLowerCase();
    return hay.includes(query.toLowerCase());
}

function playMatchesFilters(play, filters) {
    if (filters.type !== 'all' && play.type !== filters.type) return false;
    if (filters.scoring && !play.is_scoring) return false;
    if (filters.turnover && !play.is_turnover) return false;
    return true;
}

function playMarkerClass(play) {
    if (play.is_td) return 'td';
    if (play.is_turnover) return 'turnover';
    if (play.is_big) return 'big';
    return '';
}

function renderPlayTree(game, tree, primaryAbbr, primaryClass, secondaryClass) {
    const body = tree.map(q => {
        const drives = q.drives.map(d => {
            const plays = d.plays.map(p => `
                <div class="text-xs py-1 border-b border-white/5">
                    <span class="text-zinc-500 mr-2">Q${p.quarter||q.quarter}</span>
                    <span class="text-zinc-500 mr-2">${p.clock||''}</span>
                    <span class="text-zinc-400 mr-2">${p.down_distance||''}</span>
                    <span class="text-zinc-500 mr-2">${p.spot||''}</span>
                    <span class="${p.offense === primaryAbbr ? primaryClass : secondaryClass} mr-2 font-semibold">${p.offense||''}</span>
                    <span class="text-zinc-400 mr-1">${p.yards||0} yd${Math.abs(p.yards||0)!==1?'s':''}</span>
                    <span class="text-zinc-300">${p.description||''}</span>
                </div>`).join('');
            return `<details class="glass rounded-lg p-3 mt-2">
                <summary class="cursor-pointer text-xs text-zinc-400" aria-label="Drive ${d.drive_id} details">Drive ${d.drive_id} ¬∑ ${d.offense||''} ¬∑ ${d.plays.length} plays</summary>
                <div class="mt-2">${plays}</div>
            </details>`;
        }).join('');
        return `<details class="glass rounded-xl p-3 mt-3">
            <summary class="cursor-pointer text-sm text-zinc-300" aria-label="Quarter ${q.quarter} details">Quarter ${q.quarter}</summary>
            <div class="mt-2">${drives}</div>
        </details>`;
    }).join('');
    return `<div class="glass rounded-xl p-4">
        <div class="text-sm font-semibold ${primaryClass} mb-2">Game ${game.game_number} ¬∑ vs ${game.opponent} ${game.date?'('+game.date+')':''}</div>
        ${body || '<div class="text-xs text-zinc-500">No plays match this filter.</div>'}
    </div>`;
}

function renderAllPlays() {
    const ga = DATA.teams.georgia, aa = DATA.teams.asu;
    const gf = filterGames(ga.games), af = filterGames(aa.games);
    const teamGroups = [];
    if (allPlaysFilters.team === 'all' || allPlaysFilters.team === 'ga') {
        teamGroups.push({ team: ga, games: gf, key: 'georgia', teamClass: 'team-a', altClass: 'team-b' });
    }
    if (allPlaysFilters.team === 'all' || allPlaysFilters.team === 'asu') {
        teamGroups.push({ team: aa, games: af, key: 'asu', teamClass: 'team-b', altClass: 'team-a' });
    }

    const compiled = teamGroups.flatMap(group => {
        return group.games.map(game => {
            const meta = flattenPlayTree(game, group.key, group.team.name, group.team.abbr);
            const filtered = meta.plays.filter(p => playMatchesQuery(p, allPlaysQuery.trim()) && playMatchesFilters(p, allPlaysFilters));
            return { group, game, meta, filtered };
        });
    });

    const selectedPlay = allPlaysSelected
        ? compiled.flatMap(c => c.filtered).find(p => p.id === allPlaysSelected)
        : null;

    const renderBadgeRow = (play) => {
        const badges = [];
        if (play.is_td) badges.push('<span class="pbp-badge td">TD</span>');
        if (play.is_turnover) badges.push('<span class="pbp-badge turnover">Turnover</span>');
        if (play.is_big) badges.push('<span class="pbp-badge big">Big</span>');
        return badges.length ? `<div class="flex flex-wrap gap-2">${badges.join('')}</div>` : '';
    };

    const renderSelected = () => {
        if (!selectedPlay) {
            return `<div class="glass rounded-xl p-4 mb-4 text-xs text-zinc-500">Click a play marker or row to view full details.</div>`;
        }
        return `<div class="glass rounded-xl p-4 mb-4">
            <div class="text-sm font-semibold text-white mb-2">Selected Play</div>
            <div class="text-xs text-zinc-400 mb-2">G${selectedPlay.game_number} ¬∑ vs ${selectedPlay.opponent || ''} ${selectedPlay.date ? '(' + selectedPlay.date + ')' : ''}</div>
            <div class="text-sm text-zinc-200">${selectedPlay.description || 'No description available.'}</div>
            <div class="mt-3 pbp-details-grid text-xs text-zinc-400">
                <div><span class="text-zinc-500">Quarter:</span> Q${selectedPlay.quarter || ''} ¬∑ ${selectedPlay.clock || ''}</div>
                <div><span class="text-zinc-500">Down/Distance:</span> ${selectedPlay.down_distance || '‚Äî'}</div>
                <div><span class="text-zinc-500">Spot:</span> ${selectedPlay.spot || '‚Äî'}</div>
                <div><span class="text-zinc-500">Offense:</span> ${selectedPlay.offense || '‚Äî'}</div>
                <div><span class="text-zinc-500">Type:</span> ${selectedPlay.type}</div>
                <div><span class="text-zinc-500">Yards:</span> ${Number(selectedPlay.yards || 0)}</div>
            </div>
            <div class="mt-3">${renderBadgeRow(selectedPlay)}</div>
        </div>`;
    };

    const renderTimeline = (meta, plays) => {
        if (!meta.totalPlays) return `<div class="text-xs text-zinc-500">No play data.</div>`;
        const dividers = meta.quarterEnds.slice(0, -1).map(q => {
            const pct = (q.count / meta.totalPlays) * 100;
            return `<div class="pbp-divider" style="left:${pct}%;"></div>
                <div class="pbp-divider-label" style="left:${pct}%;">Q${q.quarter}</div>`;
        }).join('');
        const markers = plays.map(p => {
            const pct = meta.totalPlays <= 1 ? 50 : (p.seq / (meta.totalPlays - 1)) * 100;
            const cls = playMarkerClass(p);
            const selected = p.id === allPlaysSelected ? 'selected' : '';
            const label = `Q${p.quarter || ''} ${p.clock || ''} ¬∑ ${p.offense || ''} ¬∑ ${p.description || ''}`;
            return `<button type="button" class="pbp-marker ${cls} ${selected}" style="left:${pct}%;"
                title="${label.replace(/\"/g, '&quot;')}" onclick="selectAllPlaysPlay('${p.id}')"></button>`;
        }).join('');
        return `<div class="pbp-timeline mt-3">
            <div class="pbp-timeline-track"></div>
            ${dividers}
            ${markers}
        </div>`;
    };

    const renderTable = (plays, teamClass) => {
        if (!plays.length) return `<div class="text-xs text-zinc-500 p-3">No plays match these filters.</div>`;
        return `<div class="pbp-table text-xs">
            <div class="pbp-table-head grid grid-cols-12 gap-2 px-3 py-2 text-zinc-500">
                <div class="col-span-1">Q</div>
                <div class="col-span-2">Clock</div>
                <div class="col-span-2">Down</div>
                <div class="col-span-2">Spot</div>
                <div class="col-span-1">Off</div>
                <div class="col-span-1">Type</div>
                <div class="col-span-1 text-right">Yds</div>
                <div class="col-span-2">Play</div>
            </div>
            ${plays.map(p => {
                const desc = p.description || '';
                const short = desc.length > 48 ? desc.slice(0, 45) + '...' : desc;
                const open = p.id === allPlaysSelected ? 'open' : '';
                return `<details class="pbp-row px-3 py-2" ${open}>
                    <summary class="grid grid-cols-12 gap-2 items-center cursor-pointer" onclick="selectAllPlaysPlay('${p.id}')">
                        <div class="col-span-1 text-zinc-400">Q${p.quarter || ''}</div>
                        <div class="col-span-2 text-zinc-400">${p.clock || '‚Äî'}</div>
                        <div class="col-span-2 text-zinc-400">${p.down_distance || '‚Äî'}</div>
                        <div class="col-span-2 text-zinc-500">${p.spot || '‚Äî'}</div>
                        <div class="col-span-1 ${p.offense === p.teamAbbr ? teamClass : 'text-zinc-400'}">${p.offense || '‚Äî'}</div>
                        <div class="col-span-1 text-zinc-400">${p.type}</div>
                        <div class="col-span-1 text-right text-zinc-400">${Number(p.yards || 0)}</div>
                        <div class="col-span-2 text-zinc-200 truncate">${short || '‚Äî'}</div>
                    </summary>
                    <div class="mt-2 text-xs text-zinc-300">
                        <div class="text-zinc-400 mb-2">${desc || 'No description available.'}</div>
                        <div class="pbp-details-grid text-zinc-400">
                            <div><span class="text-zinc-500">Drive:</span> ${p.drive_id || '‚Äî'}</div>
                            <div><span class="text-zinc-500">Offense:</span> ${p.offense || '‚Äî'}</div>
                            <div><span class="text-zinc-500">Down/Distance:</span> ${p.down_distance || '‚Äî'}</div>
                            <div><span class="text-zinc-500">Spot:</span> ${p.spot || '‚Äî'}</div>
                            <div><span class="text-zinc-500">Clock:</span> ${p.clock || '‚Äî'}</div>
                            <div><span class="text-zinc-500">Yards:</span> ${Number(p.yards || 0)}</div>
                        </div>
                        <div class="mt-2">${renderBadgeRow(p)}</div>
                    </div>
                </details>`;
            }).join('')}
        </div>`;
    };

    let html = `<div class="section-enter">`;
    html += `<div class="glass rounded-xl p-4 mb-4">
        <div class="text-xs text-zinc-500 mb-2">Search all plays</div>
        <input id="allPlaysSearch" aria-label="Filter all plays" class="w-full bg-zinc-900/60 border border-white/10 rounded-lg px-3 py-2 text-sm text-zinc-200 focus:outline-none focus:border-white/20" placeholder="Filter by description, down/distance, spot, or team..." value="${allPlaysQuery}" oninput="updateAllPlaysQuery(this.value)">
        <div class="mt-3 space-y-2">
            <div class="flex flex-wrap gap-2">
                <span class="text-xs text-zinc-500 mr-1">Team</span>
                <button class="filter-chip px-2.5 py-1 rounded-md text-xs border border-white/10 ${allPlaysFilters.team==='all'?'active':''}" onclick="setAllPlaysTeam('all')">All</button>
                <button class="filter-chip px-2.5 py-1 rounded-md text-xs border border-white/10 ${allPlaysFilters.team==='ga'?'active':''}" onclick="setAllPlaysTeam('ga')">${ga.abbr}</button>
                <button class="filter-chip px-2.5 py-1 rounded-md text-xs border border-white/10 ${allPlaysFilters.team==='asu'?'active':''}" onclick="setAllPlaysTeam('asu')">${aa.abbr}</button>
            </div>
            <div class="flex flex-wrap gap-2">
                <span class="text-xs text-zinc-500 mr-1">Play Type</span>
                <button class="filter-chip px-2.5 py-1 rounded-md text-xs border border-white/10 ${allPlaysFilters.type==='all'?'active':''}" onclick="setAllPlaysType('all')">All</button>
                <button class="filter-chip px-2.5 py-1 rounded-md text-xs border border-white/10 ${allPlaysFilters.type==='rush'?'active':''}" onclick="setAllPlaysType('rush')">Rush</button>
                <button class="filter-chip px-2.5 py-1 rounded-md text-xs border border-white/10 ${allPlaysFilters.type==='pass'?'active':''}" onclick="setAllPlaysType('pass')">Pass</button>
            </div>
            <div class="flex flex-wrap gap-2">
                <span class="text-xs text-zinc-500 mr-1">Flags</span>
                <button class="filter-chip px-2.5 py-1 rounded-md text-xs border border-white/10 ${allPlaysFilters.scoring?'active':''}" onclick="toggleAllPlaysFlag('scoring')">Scoring Plays</button>
                <button class="filter-chip px-2.5 py-1 rounded-md text-xs border border-white/10 ${allPlaysFilters.turnover?'active':''}" onclick="toggleAllPlaysFlag('turnover')">Turnovers</button>
            </div>
        </div>
    </div>`;

    html += `<div class="glass rounded-xl p-4 mb-4">
        <div class="flex flex-wrap items-center gap-3 text-xs text-zinc-400">
            <span class="text-zinc-500">Timeline key:</span>
            <span class="pbp-badge td">TD</span>
            <span class="pbp-badge turnover">Turnover</span>
            <span class="pbp-badge big">Big Play</span>
        </div>
    </div>`;

    html += renderSelected();

    if (!compiled.length) {
        html += `<div class="text-xs text-zinc-500">No games available for this filter.</div>`;
        html += `</div>`;
        return html;
    }

    html += compiled.map(entry => {
        const { group, game, meta, filtered } = entry;
        return `<div class="glass rounded-xl p-4 mb-4">
            <div class="flex items-center justify-between gap-4">
                <div>
                    <div class="text-sm font-semibold ${group.teamClass}">${group.team.name}</div>
                    <div class="text-xs text-zinc-500">G${game.game_number} ¬∑ vs ${game.opponent || ''} ${game.date ? '(' + game.date + ')' : ''}</div>
                </div>
                <div class="text-xs text-zinc-500">${filtered.length} plays</div>
            </div>
            ${renderTimeline(meta, filtered)}
            <div class="mt-3">${renderTable(filtered, group.teamClass)}</div>
        </div>`;
    }).join('');

    html += `</div>`;
    return html;
}

function updateAllPlaysQuery(val) {
    allPlaysQuery = val;
    renderTab();
}

function setAllPlaysTeam(val) {
    allPlaysFilters.team = val;
    renderTab();
}

function setAllPlaysType(val) {
    allPlaysFilters.type = val;
    renderTab();
}

function toggleAllPlaysFlag(flag) {
    allPlaysFilters[flag] = !allPlaysFilters[flag];
    renderTab();
}

function selectAllPlaysPlay(id) {
    allPlaysSelected = id;
    renderTab();
}

function renderGlossary() {
    const sections = [
        {
            title: 'Offense',
            items: [
                { term: 'Points Per Game (PPG)', def: 'Average points scored per game.' },
                { term: 'Explosive Play', def: 'Rush of 15+ yards or pass of 20+ yards.' },
                { term: 'Explosives/Game', def: 'Explosive plays divided by games.' },
                { term: '4th Down Attempts', def: 'Conversion tries only (no punts or field goals).' },
                { term: '4th Down Conversions', def: 'Successful 4th down attempts.' },
                { term: '4th Down Conv %', def: 'Conversions divided by attempts.' },
                { term: 'Red Zone Trips', def: 'Offensive possessions with a snap at 20 yards or closer.' },
                { term: 'Red Zone TD/FG/Failed', def: 'Result of red zone trips: touchdowns, field goals, or no score.' },
            ]
        },
        {
            title: 'Defense',
            items: [
                { term: 'Opponent PPG', def: 'Average points allowed per game.' },
                { term: 'Explosives Allowed', def: 'Explosive plays conceded by the defense.' },
                { term: 'Explosive Rate Allowed', def: 'Explosives allowed divided by opponent plays.' },
                { term: 'Explosives/Drive Allowed', def: 'Explosives allowed divided by opponent drives.' },
                { term: 'Turnovers Forced', def: 'Total takeaways (INT + fumble recoveries).' },
                { term: 'INT Gained', def: 'Interceptions recorded by the defense.' },
                { term: 'Fumbles Gained', def: 'Opponent fumbles recovered by the defense.' },
                { term: 'Points Allowed After TO', def: 'Points allowed on drives after your team turns it over.' },
            ]
        },
        {
            title: 'Special Teams',
            items: [
                { term: 'Punt Avg', def: 'Total punt yards divided by punts.' },
                { term: 'Inside 20', def: 'Punts downed inside the opponent 20.' },
                { term: 'Inside 20%', def: 'Inside-20 punts divided by total punts.' },
                { term: 'FG %', def: 'Field goals made divided by attempts.' },
                { term: 'FG Made/Att', def: 'Field goals made and attempted.' },
                { term: 'KO Ret Avg/Long', def: 'Kickoff return average and longest return.' },
                { term: 'PR Avg/Long', def: 'Punt return average and longest return.' },
                { term: 'Return Yards', def: 'Kickoff return yards plus punt return yards.' },
            ]
        },
        {
            title: 'Situational',
            items: [
                { term: 'Record', def: 'Wins and losses (e.g., 8-2).' },
                { term: 'Turnover Margin', def: 'Takeaways minus giveaways.' },
                { term: 'Turnovers Lost', def: 'Giveaways (interceptions thrown + fumbles lost).' },
                { term: 'Points Off Turnovers', def: 'Points scored on drives after takeaways.' },
                { term: 'Middle 8', def: 'Final 4:00 of Q2 plus first 4:00 of Q3.' },
                { term: 'Middle 8 PF/PA/Diff', def: 'Points scored, allowed, and net in the middle 8.' },
                { term: 'Green Zone', def: 'Snaps at 30 yards or closer to the goal line.' },
                { term: 'Red Zone', def: 'Snaps at 20 yards or closer to the goal line.' },
                { term: 'Tight Red Zone', def: 'Snaps at 10 yards or closer to the goal line.' },
                { term: 'TD Rate', def: 'Touchdowns divided by trips into a zone.' },
                { term: 'Score Rate', def: 'Touchdowns plus field goals divided by trips.' },
                { term: 'Penalties', def: 'Total penalty flags assessed.' },
                { term: 'Penalties/Game', def: 'Penalties divided by games.' },
                { term: 'Accepted/Declined', def: 'Penalty outcomes by enforcement decision.' },
            ]
        },
    ];

    const renderSection = (section) => `
        <div class="glass rounded-xl p-4">
            <div class="text-sm font-semibold text-white mb-3">${section.title}</div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                ${section.items.map(item => `
                    <div class="border border-white/5 rounded-lg p-3 bg-white/5">
                        <div class="text-xs font-semibold text-zinc-200">${item.term}</div>
                        <div class="text-xs text-zinc-400 mt-1">${item.def}</div>
                    </div>
                `).join('')}
            </div>
        </div>
    `;

    return `<div class="section-enter space-y-4">
        ${sections.map(renderSection).join('')}
    </div>`;
}

function clearChrome() {
    const nav = document.getElementById('tabNav');
    const bar = document.getElementById('filterBar');
    if (nav) nav.innerHTML = '';
    if (bar) bar.innerHTML = '<span class="text-xs text-zinc-500 mr-1">Filter:</span>';
}

function showLoadingState() {
    clearChrome();
    const main = document.getElementById('mainContent');
    if (!main) return;
    main.innerHTML = `<div class="state-card section-enter">
        <div class="flex flex-col items-center gap-3">
            <div class="spinner"></div>
            <div class="text-sm text-zinc-300 font-medium">Loading matchup data‚Ä¶</div>
            <div class="text-xs text-zinc-500">Fetching the latest stats and play-by-play.</div>
        </div>
    </div>`;
}

function showErrorState(message) {
    clearChrome();
    const main = document.getElementById('mainContent');
    if (!main) return;
    main.innerHTML = `<div class="state-card section-enter">
        <div class="text-sm font-semibold text-red-300">Unable to load data</div>
        <div class="text-xs text-zinc-400 mt-2">${message || 'Please check your connection and try again.'}</div>
        <button class="mt-4 px-3 py-2 rounded-lg text-xs font-semibold border border-red-500/30 bg-red-500/10 text-red-200 hover:bg-red-500/20" aria-label="Retry loading data" onclick="initApp()">Retry</button>
    </div>`;
}

function showEmptyState() {
    clearChrome();
    const main = document.getElementById('mainContent');
    if (!main) return;
    main.innerHTML = `<div class="state-card section-enter">
        <div class="text-sm font-semibold text-zinc-200">No data available</div>
        <div class="text-xs text-zinc-500 mt-2">The dataset is missing or malformed. Please verify data.json and try again.</div>
        <button class="mt-4 px-3 py-2 rounded-lg text-xs font-semibold border border-white/10 bg-white/5 text-zinc-200 hover:bg-white/10" aria-label="Reload data" onclick="initApp()">Reload</button>
    </div>`;
}

function isDataValid(d) {
    if (!d || !d.teams || !d.teams.georgia || !d.teams.asu) return false;
    if (!Array.isArray(d.teams.georgia.games) || !Array.isArray(d.teams.asu.games)) return false;
    const hasGames = d.teams.georgia.games.length > 0 || d.teams.asu.games.length > 0;
    return hasGames;
}

function markChartReady(id) {
    const el = document.getElementById(id);
    if (!el) return;
    const shell = el.closest('.chart-shell');
    if (shell) shell.classList.add('chart-ready');
}

function showChartUnavailable(id, message) {
    const el = document.getElementById(id);
    if (!el) return;
    const shell = el.closest('.chart-shell');
    if (shell) shell.classList.add('chart-ready');
    el.innerHTML = `<div class="chart-fallback">${message || 'Chart unavailable.'}</div>`;
}

function safeInitChart(id, theme='dark') {
    const el = document.getElementById(id);
    if (!el) return null;
    if (!window.echarts) {
        showChartUnavailable(id, 'Charts unavailable (ECharts failed to load).');
        return null;
    }
    try {
        return echarts.init(el, theme);
    } catch (err) {
        showChartUnavailable(id, 'Chart failed to initialize.');
        return null;
    }
}

function safeSetOption(chart, id, option) {
    if (!chart) return;
    chart.setOption(option);
    markChartReady(id);
}

// ===== RENDER ENGINE =====

const renderers = {
    overview: { render: renderOverview, init: initOverviewCharts },
    explosives: { render: renderExplosives, init: initExplosivesCharts },
    redzone: { render: renderRedzone, init: initRedzoneCharts },
    turnovers: { render: renderTurnovers, init: initTurnoverCharts },
    postturnovers: { render: renderPostTurnover, init: initPostTurnoverCharts },
    penalties: { render: renderPenalties, init: initPenaltyCharts },
    middle8: { render: renderMiddle8, init: initMiddle8Charts },
    '4thdown': { render: renderFourthDown, init: initFourthDownCharts },
    specialteams: { render: renderSpecialTeams, init: initSpecialTeamsCharts },
    glossary: { render: renderGlossary },
    allplays: { render: renderAllPlays },
};

let printState = null;
let printMode = 'all';

function renderAllTabsForPrint() {
    return TABS.map(t => {
        const r = renderers[t.id];
        if (!r) return '';
        return `<section class="print-section">
            <div class="print-section-title">${t.icon} ${t.label}</div>
            ${r.render()}
        </section>`;
    }).join('');
}

function beforePrint() {
    if (!DATA || printState) return;
    const main = document.getElementById('mainContent');
    printState = { html: main.innerHTML, tab: currentTab };
    if (printMode === 'all') {
        main.innerHTML = renderAllTabsForPrint();
        Object.values(renderers).forEach(r => { if (r.init) r.init(); });
    }
}

function afterPrint() {
    if (!printState) return;
    const main = document.getElementById('mainContent');
    currentTab = printState.tab;
    main.innerHTML = printState.html;
    printState = null;
    buildNav();
    renderTab();
}

function renderTab() {
    const main = document.getElementById('mainContent');
    const r = renderers[currentTab];
    main.innerHTML = r ? r.render() : '';
    updateTabTitle(currentTab);
    if (r && r.init) setTimeout(r.init, 50);
}

function buildNav() {
    const nav = document.getElementById('tabNav');
    nav.innerHTML = TABS.map((t, idx) =>
        `<button id="tab-${t.id}" role="tab" aria-controls="mainContent" aria-selected="${t.id===currentTab?'true':'false'}" tabindex="${t.id===currentTab?0:-1}" class="nav-pill px-3 py-1.5 rounded-lg text-xs font-medium border border-transparent whitespace-nowrap ${t.id===currentTab?'active':''}" data-tab="${t.id}" data-index="${idx}" aria-label="${t.label} tab" onclick="switchTab('${t.id}', true)">${t.icon} ${t.label}</button>`
    ).join('');
}

function buildFilters() {
    const bar = document.getElementById('filterBar');
    bar.innerHTML = '<span class="text-xs text-zinc-500 mr-1">Filter:</span>' + FILTERS.map(f =>
        `<button class="filter-chip px-2.5 py-1 rounded-md text-xs border border-white/10 ${f.id===currentFilter?'active':''}" aria-pressed="${f.id===currentFilter?'true':'false'}" aria-label="Filter ${f.label}" onclick="switchFilter('${f.id}')">${f.label}</button>`
    ).join('');
}

function switchTab(id, focusTab = false) {
    currentTab = id;
    buildNav();
    renderTab();
    announceTabChange(id);
    if (focusTab) focusActiveTab();
    updateHashState();
}

function updateHeader() {
    const ga = DATA.teams.georgia, aa = DATA.teams.asu;
    const gf = filterGames(ga.games), af = filterGames(aa.games);
    const gs = agg(gf), as_ = agg(af);
    document.getElementById('teamARecord').textContent = gs.record + ' ¬∑ ' + ga.conference;
    document.getElementById('teamBRecord').textContent = as_.record + ' ¬∑ ' + aa.conference;
    const gQuality = computeTeamQuality(gf);
    const aQuality = computeTeamQuality(af);
    const teamAQuality = document.getElementById('teamAQuality');
    const teamBQuality = document.getElementById('teamBQuality');
    teamAQuality.innerHTML = `${qualityBadge(gQuality, 'Data')}<span class="dq-tooltip-content">${qualityTooltipHtml('Team data quality', gQuality)}</span>`;
    teamBQuality.innerHTML = `${qualityBadge(aQuality, 'Data')}<span class="dq-tooltip-content">${qualityTooltipHtml('Team data quality', aQuality)}</span>`;
}

function switchFilter(id) {
    currentFilter = id;
    buildFilters();
    updateHeader();
    renderTab();
    updateHashState();
}

function closeMenus() {
    document.getElementById('exportPanel')?.classList.add('hidden');
    document.getElementById('sharePanel')?.classList.add('hidden');
    document.getElementById('exportToggle')?.setAttribute('aria-expanded', 'false');
    document.getElementById('shareToggle')?.setAttribute('aria-expanded', 'false');
}

function toggleMenu(panelId) {
    const panel = document.getElementById(panelId);
    if (!panel) return;
    const isOpen = !panel.classList.contains('hidden');
    closeMenus();
    if (!isOpen) {
        panel.classList.remove('hidden');
        if (panelId === 'exportPanel') document.getElementById('exportToggle')?.setAttribute('aria-expanded', 'true');
        if (panelId === 'sharePanel') document.getElementById('shareToggle')?.setAttribute('aria-expanded', 'true');
    }
}

function copyShareLink() {
    const url = buildShareUrl();
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(url).then(() => {
            closeMenus();
        }).catch(() => {
            fallbackCopy(url);
            closeMenus();
        });
    } else {
        fallbackCopy(url);
        closeMenus();
    }
}

function fallbackCopy(text) {
    const input = document.createElement('input');
    input.value = text;
    document.body.appendChild(input);
    input.select();
    document.execCommand('copy');
    document.body.removeChild(input);
}

function exportCurrentViewPdf() {
    printMode = 'current';
    window.print();
    setTimeout(() => { printMode = 'all'; }, 0);
    closeMenus();
}

function downloadRawJson() {
    if (!DATA) return;
    const blob = new Blob([JSON.stringify(DATA, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'data.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    closeMenus();
}

function csvEscape(value) {
    const str = (value ?? '').toString().replace(/\r?\n/g, ' ').trim();
    if (/[",\n]/.test(str)) return `"${str.replace(/"/g, '""')}"`;
    return str;
}

function tableToCsv(table) {
    const rows = Array.from(table.querySelectorAll('tr'));
    return rows.map(row => {
        const cells = Array.from(row.querySelectorAll('th,td')).map(cell => csvEscape(cell.textContent));
        return cells.join(',');
    }).join('\n');
}

function getTableTitle(table) {
    const collapsible = table.closest('.collapsible-body');
    if (collapsible && collapsible.previousElementSibling?.classList.contains('collapsible-toggle')) {
        return collapsible.previousElementSibling.textContent.trim();
    }
    const tab = TABS.find(t => t.id === currentTab);
    return tab ? tab.label : 'Export';
}

function exportCurrentTabCsv() {
    const main = document.getElementById('mainContent');
    if (!main) return;
    const tables = Array.from(main.querySelectorAll('table'));
    if (!tables.length) {
        alert('No tables found in the current tab.');
        closeMenus();
        return;
    }
    let csv = '';
    tables.forEach((table, idx) => {
        if (tables.length > 1) {
            if (idx > 0) csv += '\n\n';
            csv += `${csvEscape(getTableTitle(table))}\n`;
        }
        csv += tableToCsv(table);
    });
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const tabLabel = (TABS.find(t => t.id === currentTab)?.label || 'tab').toLowerCase().replace(/\s+/g, '-');
    const a = document.createElement('a');
    a.href = url;
    a.download = `matchup-${tabLabel}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    closeMenus();
}

function shareToTwitter() {
    const url = buildShareUrl();
    const text = `Matchup analysis: ${document.getElementById('teamAName')?.textContent || ''} vs ${document.getElementById('teamBName')?.textContent || ''}`.trim();
    const shareUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`;
    window.open(shareUrl, '_blank', 'noopener,noreferrer');
    closeMenus();
}

function shareViaEmail() {
    const url = buildShareUrl();
    const subject = `Matchup analysis: ${document.getElementById('teamAName')?.textContent || ''} vs ${document.getElementById('teamBName')?.textContent || ''}`.trim();
    const body = `Here is the matchup view:\n${url}`;
    window.location.href = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
    closeMenus();
}

let menusReady = false;

function initMenus() {
    if (menusReady) return;
    menusReady = true;
    const exportToggle = document.getElementById('exportToggle');
    const shareToggle = document.getElementById('shareToggle');
    exportToggle?.addEventListener('click', e => {
        e.stopPropagation();
        toggleMenu('exportPanel');
    });
    shareToggle?.addEventListener('click', e => {
        e.stopPropagation();
        toggleMenu('sharePanel');
    });
    document.addEventListener('click', closeMenus);
    document.addEventListener('keydown', e => {
        if (e.key === 'Escape') closeMenus();
    });
}

let keyboardControlsReady = false;
let lastFocusedElement = null;

function isTypingTarget(target) {
    if (!target) return false;
    const tag = target.tagName ? target.tagName.toLowerCase() : '';
    return tag === 'input' || tag === 'textarea' || target.isContentEditable;
}

function getTabIndexById(id) {
    return TABS.findIndex(t => t.id === id);
}

function focusActiveTab() {
    const activeBtn = document.querySelector(`#tabNav [data-tab="${currentTab}"]`);
    if (activeBtn) activeBtn.focus();
}

function focusTabByIndex(idx, focus = true) {
    const target = TABS[idx];
    if (!target) return;
    switchTab(target.id, false);
    if (focus) focusActiveTab();
}

function announceTabChange(id) {
    const announcer = document.getElementById('srAnnouncement');
    const main = document.getElementById('mainContent');
    const title = getTabTitle(id);
    if (main) {
        main.setAttribute('aria-label', `${title} tab content`);
        main.setAttribute('aria-labelledby', `tab-${id}`);
    }
    if (announcer) announcer.textContent = `${title} tab selected.`;
}

function handleTabArrowNav(e) {
    const tabNav = document.getElementById('tabNav');
    const isInTabNav = document.activeElement && document.activeElement.closest && document.activeElement.closest('#tabNav');
    if (!tabNav || !isInTabNav) return;
    const currentIdx = getTabIndexById(currentTab);
    if (currentIdx < 0) return;
    if (e.key === 'ArrowRight') {
        e.preventDefault();
        focusTabByIndex((currentIdx + 1) % TABS.length);
    } else if (e.key === 'ArrowLeft') {
        e.preventDefault();
        focusTabByIndex((currentIdx - 1 + TABS.length) % TABS.length);
    }
}

function handleNumberShortcut(e) {
    if (!/^[1-9]$/.test(e.key)) return;
    const idx = Number(e.key) - 1;
    if (idx < TABS.length) {
        e.preventDefault();
        focusTabByIndex(idx);
    }
}

function focusSearchInput() {
    const input = document.getElementById('allPlaysSearch');
    if (!input) return false;
    input.focus();
    input.select();
    return true;
}

function closeExpandedSections() {
    document.querySelectorAll('.collapsible-body.open').forEach(body => {
        body.classList.remove('open');
        const btn = document.querySelector(`[aria-controls="${body.id}"]`);
        if (btn) {
            btn.setAttribute('aria-expanded', 'false');
            const chevron = btn.querySelector('.chevron');
            if (chevron) chevron.classList.remove('open');
        }
    });
    document.querySelectorAll('details[open]').forEach(detail => {
        detail.open = false;
    });
}

function openKeyboardHelp() {
    const modal = document.getElementById('kbdModal');
    if (!modal) return;
    lastFocusedElement = document.activeElement;
    modal.classList.add('open');
    modal.setAttribute('aria-hidden', 'false');
    document.body.classList.add('modal-open');
    const closeBtn = document.getElementById('kbdCloseBtn');
    if (closeBtn) closeBtn.focus();
}

function closeKeyboardHelp() {
    const modal = document.getElementById('kbdModal');
    if (!modal) return;
    modal.classList.remove('open');
    modal.setAttribute('aria-hidden', 'true');
    document.body.classList.remove('modal-open');
    if (lastFocusedElement && typeof lastFocusedElement.focus === 'function') {
        lastFocusedElement.focus();
    }
}

function trapModalFocus(e) {
    const modal = document.getElementById('kbdModal');
    if (!modal || !modal.classList.contains('open')) return;
    if (e.key !== 'Tab') return;
    const focusable = modal.querySelectorAll('button, [href], input, [tabindex]:not([tabindex="-1"])');
    if (!focusable.length) return;
    const first = focusable[0];
    const last = focusable[focusable.length - 1];
    if (e.shiftKey && document.activeElement === first) {
        e.preventDefault();
        last.focus();
    } else if (!e.shiftKey && document.activeElement === last) {
        e.preventDefault();
        first.focus();
    }
}

function initKeyboardControls() {
    if (keyboardControlsReady) return;
    keyboardControlsReady = true;
    const helpBtn = document.getElementById('kbdHelpBtn');
    const closeBtn = document.getElementById('kbdCloseBtn');
    const modal = document.getElementById('kbdModal');
    helpBtn?.addEventListener('click', openKeyboardHelp);
    closeBtn?.addEventListener('click', closeKeyboardHelp);
    modal?.addEventListener('click', e => {
        if ((e.target && e.target.dataset && e.target.dataset.close === 'kbd') || e.target === modal) {
            closeKeyboardHelp();
        }
    });
    document.addEventListener('keydown', e => {
        if (e.key === 'Escape' && modal?.classList.contains('open')) {
            e.preventDefault();
            closeKeyboardHelp();
            return;
        }
        trapModalFocus(e);
    });
    document.addEventListener('keydown', e => {
        if (modal?.classList.contains('open')) return;
        if (isTypingTarget(e.target)) {
            if (e.key === 'Escape') closeExpandedSections();
            return;
        }
        if (e.key === '?' || (e.shiftKey && e.key === '/')) {
            e.preventDefault();
            openKeyboardHelp();
            return;
        }
        if (e.key === '/') {
            if (focusSearchInput()) e.preventDefault();
            return;
        }
        if (e.key === 'Escape') {
            closeExpandedSections();
            return;
        }
        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
            handleTabArrowNav(e);
            return;
        }
        handleNumberShortcut(e);
    });
}

let touchTabsReady = false;

function hasScrollableAncestor(el) {
    let cur = el;
    while (cur && cur !== document.body && cur !== document.documentElement) {
        if (cur instanceof HTMLElement) {
            const style = window.getComputedStyle(cur);
            if ((style.overflowX === 'auto' || style.overflowX === 'scroll') && cur.scrollWidth > cur.clientWidth + 1) {
                return true;
            }
        }
        cur = cur.parentElement;
    }
    return false;
}

function isSwipeBlocked(target) {
    if (!target || !target.closest) return false;
    if (target.closest('table, .collapsible-body, .pbp-table, #tabNav, [data-swipe-block]')) return true;
    return hasScrollableAncestor(target);
}

function initTouchTabs() {
    if (touchTabsReady) return;
    touchTabsReady = true;
    const main = document.getElementById('mainContent');
    if (!main) return;
    let startX = 0;
    let startY = 0;
    let startTime = 0;
    let tracking = false;

    main.addEventListener('touchstart', e => {
        if (e.touches.length !== 1) return;
        if (document.body.classList.contains('modal-open')) return;
        if (isTypingTarget(e.target) || isSwipeBlocked(e.target)) return;
        const touch = e.touches[0];
        startX = touch.clientX;
        startY = touch.clientY;
        startTime = Date.now();
        tracking = true;
    }, { passive: true });

    main.addEventListener('touchend', e => {
        if (!tracking || e.changedTouches.length !== 1) return;
        tracking = false;
        const touch = e.changedTouches[0];
        const dx = touch.clientX - startX;
        const dy = touch.clientY - startY;
        const absX = Math.abs(dx);
        const absY = Math.abs(dy);
        const dt = Date.now() - startTime;
        if (absX < 60 || absY > 40 || dt > 650) return;
        const currentIdx = getTabIndexById(currentTab);
        if (currentIdx < 0) return;
        const nextIdx = dx < 0 ? (currentIdx + 1) % TABS.length : (currentIdx - 1 + TABS.length) % TABS.length;
        focusTabByIndex(nextIdx, false);
    }, { passive: true });
}

// ===== INIT =====
function initApp() {
    initMenus();
    initKeyboardControls();
    initTouchTabs();
    showLoadingState();
    fetch('data.json').then(r => {
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        return r.json();
    }).then(d => {
        if (!isDataValid(d)) {
            showEmptyState();
            return;
        }
        DATA = d;
        applyHashState();
        const ga = d.teams.georgia, aa = d.teams.asu;
        document.getElementById('teamAName').textContent = ga.name;
        document.getElementById('teamBName').textContent = aa.name;
        buildNav();
        buildFilters();
        updateHeader();
        renderTab();
        announceTabChange(currentTab);
        updateHashState();

        window.addEventListener('beforeprint', beforePrint);
        window.addEventListener('afterprint', afterPrint);
        window.addEventListener('orientationchange', () => window.dispatchEvent(new Event('resize')));
        if (window.matchMedia) {
            const media = window.matchMedia('print');
            if (media.addEventListener) {
                media.addEventListener('change', e => (e.matches ? beforePrint() : afterPrint()));
            } else if (media.addListener) {
                media.addListener(e => (e.matches ? beforePrint() : afterPrint()));
            }
        }
    }).catch(e => {
        showErrorState(`Failed to load data.json (${e.message}).`);
    });
}

initApp();
</script>
<a href="https://vtsportssolutions.com" target="_blank" rel="noopener" aria-label="VT Sports Solutions website" class="mobile-hide" style="position:fixed;bottom:1rem;right:1rem;z-index:40;display:flex;align-items:center;gap:0.5rem;padding:0.625rem 1rem;background:rgba(255,255,255,0.95);backdrop-filter:blur(8px);border-radius:9999px;box-shadow:0 4px 12px rgba(0,0,0,0.1);border:1px solid rgba(0,0,0,0.08);text-decoration:none;transition:transform 0.2s,box-shadow 0.2s;">
  <span style="font-size:0.75rem;color:#666;white-space:nowrap;">made with ‚ù§Ô∏è by</span>
  <img src="assets/vt-logo-text.png" alt="VT Sports Solutions" style="height:20px;">
</a>
</body>
</html>
